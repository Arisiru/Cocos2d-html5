<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CocosJS Source: input/MouseInputManager.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CocosJS</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#cc">cc</a>
						</li>
						
						<li>
							<a href="global.html#cc#action">cc.action</a>
						</li>
						
						<li>
							<a href="cc.Debug.html">cc.Debug</a>
						</li>
						
						<li>
							<a href="cc.game.html">cc.game</a>
						</li>
						
						<li>
							<a href="cc.input.html">cc.input</a>
						</li>
						
						<li>
							<a href="cc.locale.html">cc.locale</a>
						</li>
						
						<li>
							<a href="cc.math.html">cc.math</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html">cc.math.path</a>
						</li>
						
						<li>
							<a href="cc.node.html">cc.node</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.html">cc.node.sprite</a>
						</li>
						
						<li>
							<a href="cc.plugin.html">cc.plugin</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.html">cc.plugin.asset</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.html">cc.plugin.audio</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.html">cc.plugin.layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.html">cc.plugin.loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.html">cc.plugin.texture</a>
						</li>
						
						<li>
							<a href="cc.render.html">cc.render</a>
						</li>
						
						<li>
							<a href="cc.render.shader.html">cc.render.shader</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLState.html">cc.render.WebGLState</a>
						</li>
						
						<li>
							<a href="cc.transition.html">cc.transition</a>
						</li>
						
						<li>
							<a href="cc.util.html">cc.util</a>
						</li>
						
						<li>
							<a href="cc.widget.html">cc.widget</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cc.action.Action.html">cc.action.Action</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext.html">cc.action.ActionChainContext</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext_constructor.html">cc.action.ActionChainContext#constructor</a>
						</li>
						
						<li>
							<a href="cc.action.ActionInfo.html">cc.action.ActionInfo</a>
						</li>
						
						<li>
							<a href="cc.action.ActionManager.html">cc.action.ActionManager</a>
						</li>
						
						<li>
							<a href="cc.action.AlphaAction.html">cc.action.AlphaAction</a>
						</li>
						
						<li>
							<a href="cc.action.AnimateAction.html">cc.action.AnimateAction</a>
						</li>
						
						<li>
							<a href="cc.action.Interpolator.html">cc.action.Interpolator</a>
						</li>
						
						<li>
							<a href="cc.action.JumpAction.html">cc.action.JumpAction</a>
						</li>
						
						<li>
							<a href="cc.action.MoveAction.html">cc.action.MoveAction</a>
						</li>
						
						<li>
							<a href="cc.action.ParseInterpolator.html">cc.action.ParseInterpolator</a>
						</li>
						
						<li>
							<a href="cc.action.PathAction.html">cc.action.PathAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyAction.html">cc.action.PropertyAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyInfo.html">cc.action.PropertyInfo</a>
						</li>
						
						<li>
							<a href="cc.action.RotateAction.html">cc.action.RotateAction</a>
						</li>
						
						<li>
							<a href="cc.action.ScaleAction.html">cc.action.ScaleAction</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueue.html">cc.action.SchedulerQueue</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueueTask.html">cc.action.SchedulerQueueTask</a>
						</li>
						
						<li>
							<a href="cc.action.SequenceAction.html">cc.action.SequenceAction</a>
						</li>
						
						<li>
							<a href="cc.action.TintAction.html">cc.action.TintAction</a>
						</li>
						
						<li>
							<a href="cc.game.Game.html">cc.game.Game</a>
						</li>
						
						<li>
							<a href="cc.input.InputManager.html">cc.input.InputManager</a>
						</li>
						
						<li>
							<a href="cc.input.InputManagerEvent.html">cc.input.InputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.KeyActionInfo.html">cc.input.KeyActionInfo</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardCursor.html">cc.input.KeyboardCursor</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardInputManager.html">cc.input.KeyboardInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.KeyInfo.html">cc.input.KeyInfo</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManager.html">cc.input.MouseInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManagerEvent.html">cc.input.MouseInputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.PriorityInputNode.html">cc.input.PriorityInputNode</a>
						</li>
						
						<li>
							<a href="cc.input.SceneGraphInputTreeNode.html">cc.input.SceneGraphInputTreeNode</a>
						</li>
						
						<li>
							<a href="cc.math.Color.html">cc.math.Color</a>
						</li>
						
						<li>
							<a href="cc.math.Dimension.html">cc.math.Dimension</a>
						</li>
						
						<li>
							<a href="cc.math.Matrix3.html">cc.math.Matrix3</a>
						</li>
						
						<li>
							<a href="cc.math.Path.html">cc.math.Path</a>
						</li>
						
						<li>
							<a href="cc.math.path.ContainerSegment.html">cc.math.path.ContainerSegment</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentArc.html">cc.math.path.SegmentArc</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentBezier.html">cc.math.path.SegmentBezier</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentCardinalSpline.html">cc.math.path.SegmentCardinalSpline</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html#SegmentLine">cc.math.path.SegmentLine</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentQuadratic.html">cc.math.path.SegmentQuadratic</a>
						</li>
						
						<li>
							<a href="cc.math.path.SubPath.html">cc.math.path.SubPath</a>
						</li>
						
						<li>
							<a href="cc.math.Rectangle.html">cc.math.Rectangle</a>
						</li>
						
						<li>
							<a href="cc.math.Vector.html">cc.math.Vector</a>
						</li>
						
						<li>
							<a href="cc.node.Director.html">cc.node.Director</a>
						</li>
						
						<li>
							<a href="cc.node.FastSprite.html">cc.node.FastSprite</a>
						</li>
						
						<li>
							<a href="cc.node.Node.html">cc.node.Node</a>
						</li>
						
						<li>
							<a href="cc.node.Scene.html">cc.node.Scene</a>
						</li>
						
						<li>
							<a href="cc.node.Sprite_.html">cc.node.Sprite</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.Animation.html">cc.node.sprite.Animation</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.AnimationCache.html">cc.node.sprite.AnimationCache</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.SpriteFrame.html">cc.node.sprite.SpriteFrame</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.AssetManager.html">cc.plugin.asset.AssetManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioEffect.html">cc.plugin.audio.AudioEffect</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioManager.html">cc.plugin.audio.AudioManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.FontMetrics.html">cc.plugin.font.FontMetrics</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFont.html">cc.plugin.font.SpriteFont</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFontChar.html">cc.plugin.font.SpriteFontChar</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.BorderLayout.html">cc.plugin.layout.BorderLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Gap.html">cc.plugin.layout.Gap</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.GridLayout.html">cc.plugin.layout.GridLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Insets.html">cc.plugin.layout.Insets</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.LayerLayout.html">cc.plugin.layout.LayerLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Layout.html">cc.plugin.layout.Layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Unit.html">cc.plugin.layout.Unit</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.Loader.html">cc.plugin.loader.Loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderAudioBuffer.html">cc.plugin.loader.ResourceLoaderAudioBuffer</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderImage.html">cc.plugin.loader.ResourceLoaderImage</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderJSON.html">cc.plugin.loader.ResourceLoaderJSON</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderXML.html">cc.plugin.loader.ResourceLoaderXML</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePacker.html">cc.plugin.texture.TexturePacker</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerNode.html">cc.plugin.texture.TexturePackerNode</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerPage.html">cc.plugin.texture.TexturePackerPage</a>
						</li>
						
						<li>
							<a href="cc.render.CanvasRenderer.html">cc.render.CanvasRenderer</a>
						</li>
						
						<li>
							<a href="cc.render.DecoratedWebGLRenderingContext.html">cc.render.DecoratedWebGLRenderingContext</a>
						</li>
						
						<li>
							<a href="cc.render.GeometryBatcher.html">cc.render.GeometryBatcher</a>
						</li>
						
						<li>
							<a href="cc.render.Pattern.html">cc.render.Pattern</a>
						</li>
						
						<li>
							<a href="cc.render.Renderer.html">cc.render.Renderer</a>
						</li>
						
						<li>
							<a href="cc.render.RenderingContextSnapshot.html">cc.render.RenderingContextSnapshot</a>
						</li>
						
						<li>
							<a href="cc.render.ScaleManager.html">cc.render.ScaleManager</a>
						</li>
						
						<li>
							<a href="cc.render.shader.AbstractShader.html">cc.render.shader.AbstractShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Attribute.html">cc.render.shader.Attribute</a>
						</li>
						
						<li>
							<a href="cc.render.shader.MatrixUniform.html">cc.render.shader.MatrixUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.SolidColorShader.html">cc.render.shader.SolidColorShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureShader.html">cc.render.shader.TextureShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureUniform.html">cc.render.shader.TextureUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Uniform.html">cc.render.shader.Uniform</a>
						</li>
						
						<li>
							<a href="cc.render.Texture2D.html">cc.render.Texture2D</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLRenderer.html">cc.render.WebGLRenderer</a>
						</li>
						
						<li>
							<a href="cc.transition.Transition.html">cc.transition.Transition</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionFade.html">cc.transition.TransitionFade</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionMove.html">cc.transition.TransitionMove</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInB.html">cc.transition.TransitionSlideInB</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInL.html">cc.transition.TransitionSlideInL</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInR.html">cc.transition.TransitionSlideInR</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInT.html">cc.transition.TransitionSlideInT</a>
						</li>
						
						<li>
							<a href="cc.util.Resource.html">cc.util.Resource</a>
						</li>
						
						<li>
							<a href="cc.widget.Button.html">cc.widget.Button</a>
						</li>
						
						<li>
							<a href="cc.widget.Label.html">cc.widget.Label</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#__extends">__extends</a>
						</li>
						
						<li>
							<a href="global.html#test">test</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: input/MouseInputManager.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/**
 * License: see license.txt file.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// &lt;reference path="../math/Point.ts"/>
/// &lt;reference path="../node/Node.ts"/>
/// &lt;reference path="../node/Scene.ts"/>
/// &lt;reference path="InputManager.ts"/>
var cc;
(function (cc) {
    var input;
    (function (input) {
        var Vector = cc.math.Vector;
        var InputManagerEvent = cc.input.InputManagerEvent;
        var __p0 = new Vector();
        /**
         * DOM target element. Tipically a Canvas object.
         * Director will call this method when the renderer is set.
         * @type {HTMLElement}
         * @private
         */
        var _target = null;
        /**
         * Current event screen-space point.
         * @type {cc.math.Vector}
         * @private
         */
        var _screenPoint = new Vector();
        /**
         * Previous event screen-space point. When a drag event is detected, the event emitted will contain current and
         * previous screen coordinated which will allow for a proper dragging calculation w/o the client need to store
         * previous coords.
         * @type {cc.math.Vector}
         * @private
         */
        var _prevScreenPoint = new Vector();
        /**
         * Mouse event in _target space. For a node this will have the _screenPoint transformed to node's local coordinate
         * system (regardless of the compound affine transform it has).
         * @type {cc.math.Vector}
         * @private
         */
        var _targetPoint = new Vector();
        /**
         * This is director's current scene.
         * It is needed since each scene will have two lists for input: priority and scene-graph order.
         * @type {cc.node.Scene}
         * @private
         */
        var _scene = null;
        /**
         * Flag indicating whether the mouse/touch is pressed when moving. This allows to differentiate between move and drag.
         * @type {boolean}
         * @private
         */
        var _isMouseDown = false;
        /**
         * Is dragging internal flag.
         * @type {boolean}
         * @private
         */
        var _isDragging = false;
        var _isDraggingInCapture = false;
        /**
         * When the mouse/pointer is down, a target Node is identified as event target.
         * This variable holds a Node reference as capturing Node.
         * @type {cc.node.Node}
         * @private
         */
        var _currentCaptureNode = null;
        /**
         * Internal flag that identifies an IOS user agent.
          * @type {Navigator|string[]}
         */
        var isIOS = navigator &amp;&amp; navigator.userAgent.match(/iOS/);
        /**
         * Create a MouseInputManagerEvent.
         * This event contains:
         *   + target for the event. A Node.
         *   + type of event (mouseover, mouseout, mousedown, mouseup, mousemove, mousedrag, mouseclick, doubleclick)
         *   + screen point (canvas space) where the event originated.
         *   + previous screen point (canvas space) where the event originated in the previous event.
         *   + local node point (node space) where the event originated in the previous event.
         *
         * WARNING: all properties of this event must be copied. Don't rely on the point values unless you make a copy
         * of them.
         * WARNING: don't change any of the event properties in the callback functions it is passed to.
         *
         * @param e {MouseEvent} original DOM event
         * @param event {string} the type of event that will be emitted.
         * @param node {cc.node.Node} a target node.
         *
         * @returns {MouseInputManagerEvent}
         */
        function createEvent(e, event, node) {
            var mie = new MouseInputManagerEvent(e);
            getTargetSpacePoint(__p0, e);
            // original canvas-space position
            mie.setScreenPoint(__p0.x, __p0.y);
            if (null === _prevScreenPoint) {
                _prevScreenPoint = new Vector(__p0.x, __p0.y);
            }
            mie.localPoint.x = mie.screenPoint.x;
            mie.localPoint.y = mie.screenPoint.y;
            mie.prevScreenPoint.x = _prevScreenPoint.x;
            mie.prevScreenPoint.y = _prevScreenPoint.y;
            mie.initializeEventForTarget(node, event);
            return mie;
        }
        function routeEvent(p, callback) {
            if (_scene) {
                return _scene.findNodeAtScreenPoint(p, callback);
            }
            return null;
        }
        /**
         * Mouse down handler.
         * @param e {MouseEvent}
         */
        function mouseDown(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputDown(createEvent(e, "mousedown", _currentCaptureNode), "mousedown");
        }
        function __inputDown(ee, event) {
            _isMouseDown = true;
            ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
            routeEvent(ee._localPoint, function (node) {
                var ret = false;
                if (node) {
                    ee._type = event;
                    ee._target = node;
                    ret = node.notifyEvent(ee);
                }
                if (_currentCaptureNode !== node &amp;&amp; !ret) {
                    if (_currentCaptureNode) {
                        ee._type = event === "mousedown" ? "mouseout" : "touchend";
                        ee._target = _currentCaptureNode;
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }
                if (!ret) {
                    _currentCaptureNode = node;
                }
                _prevScreenPoint.set(ee.screenPoint.x, ee.screenPoint.y);
                return ret;
            });
        }
        /**
         * Mouse up handler
         * @param e {MouseEvent}
         */
        function mouseUp(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputUp(createEvent(e, "mouseup", _currentCaptureNode), "mouseup");
        }
        function __inputUp(ee, event) {
            ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
            var node = routeEvent(ee._localPoint);
            var ret = false;
            if (_currentCaptureNode) {
                // up in a different node
                if (_currentCaptureNode !== node) {
                    // send out to the previous one.
                    ee._type = event === "mouseup" ? "mouseout" : "touchend";
                    ee._target = _currentCaptureNode;
                    ee.localPoint.x = ee.screenPoint.x;
                    ee.localPoint.y = ee.screenPoint.y;
                    _currentCaptureNode.isScreenPointInNode(ee.localPoint);
                    _currentCaptureNode.notifyEvent(ee);
                }
                else {
                    // up in the same captured node
                    // notify mouse up
                    _currentCaptureNode.notifyEvent(ee);
                    // and if not dragging, mouse click
                    if (!_isDragging &amp;&amp; event === "mouseup") {
                        ee._type = "mouseclick";
                        ee._target = _currentCaptureNode;
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }
            }
            _currentCaptureNode = null;
            _isMouseDown = false;
            _isDragging = false;
            _isDraggingInCapture = false;
            _prevScreenPoint = null;
        }
        /**
         * Mouse move handler
         * @param e {MouseEvent}
         * @param _event {string} mouseout/mouseover are treated as mouseMove. If set, this variable forces the event type.
         */
        function mouseMove(e, _event) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            var event = _event ? _event : (_isMouseDown ? "mousedrag" : "mousemove");
            __inputMove(createEvent(e, event, _currentCaptureNode), event);
        }
        function __inputMove(ee, event) {
            if (_isMouseDown) {
                _isDragging = true;
                _isDraggingInCapture = true;
            }
            // drag is sent to the captured node.
            if (!_isDragging) {
                ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
                routeEvent(ee._localPoint, function (node) {
                    var ret = false;
                    if (node) {
                        ee._type = event;
                        ee._target = node;
                        ret = node.notifyEvent(ee);
                    }
                    if (node !== _currentCaptureNode &amp;&amp; !ret) {
                        // if there's a previous capture node notify mouse-out on it.
                        if (_currentCaptureNode) {
                            ee._type = event === "mousedrag" || event === "mousemove" ? "mouseout" : "touchout";
                            ee._target = _currentCaptureNode;
                            _currentCaptureNode.notifyEvent(ee);
                        }
                        if (node) {
                            ee._type = event === "mousedrag" || event === "mousemove" ? "mouseover" : "touchover";
                            ee._target = node;
                            ret = node.notifyEvent(ee);
                        }
                    }
                    if (!ret) {
                        _currentCaptureNode = node;
                    }
                    _prevScreenPoint.set(ee.screenPoint.x, ee.screenPoint.y);
                    return ret;
                });
            }
            else {
                // dragging
                // dragging outside the capture node ??
                //routeEvent( ee.screenPoint, function(node:Node) : boolean {
                ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
                var node = routeEvent(ee._localPoint);
                var ret = false;
                if (node !== _currentCaptureNode) {
                    if (_currentCaptureNode) {
                        ee._type = ee._type = event === "mousedrag" || event === "mousemove" ? "mouseout" : "touchout";
                        ee.localPoint.x = ee.screenPoint.x;
                        ee.localPoint.y = ee.screenPoint.y;
                        _currentCaptureNode.getScreenPointInLocalSpace(ee.localPoint);
                        _currentCaptureNode.notifyEvent(ee);
                        _isDraggingInCapture = false;
                    }
                }
                else {
                    if (!_isDraggingInCapture) {
                        _isDraggingInCapture = true;
                        ee._type = ee._type = event === "mousedrag" || event === "mousemove" ? "mouseover" : "touchover";
                        _currentCaptureNode.notifyEvent(ee);
                    }
                }
                // notify mouse-over to the new capture node
                if (_currentCaptureNode !== null) {
                    ee._type = event;
                    ee._target = _currentCaptureNode;
                    //ret= _currentCaptureNode.notifyEvent( ee );
                    ret = _currentCaptureNode.notifyEvent(ee);
                }
                _prevScreenPoint.set(ee.screenPoint.x, ee.screenPoint.y);
            }
        }
        /**
         * double click handler.
         * @param e {MouseEvent}
         */
        function doubleClick(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            var ee = createEvent(e, "doubleclick", _currentCaptureNode);
            if (_currentCaptureNode) {
                _currentCaptureNode.notifyEvent(ee);
            }
            else {
                ee._localPoint.set(ee._screenPoint.x, ee._screenPoint.y);
                routeEvent(ee._localPoint, function (node) {
                    var ret = false;
                    if (_currentCaptureNode) {
                        ret = _currentCaptureNode.notifyEvent(ee);
                    }
                    return ret;
                });
            }
            _prevScreenPoint = null;
        }
        /**
         * Mouse over handler.
         * @param e {MouseEvent}
         */
        function mouseOver(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            mouseMove(e, "mouseoever");
        }
        /**
         * Mouse out handler
         * @param e {MouseEvent}
         */
        function mouseOut(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            mouseMove(e, "mouseout");
        }
        function touchStart(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputDown(createEvent(e.targetTouches[0], "touchstart", _currentCaptureNode), "touchstart");
        }
        function touchEnd(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputUp(createEvent(e.changedTouches[0], "touchend", _currentCaptureNode), "touchend");
        }
        function touchMove(e) {
            e.preventDefault();
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (!_scene) {
                return;
            }
            __inputMove(createEvent(e.targetTouches[0], "touchmove", _currentCaptureNode), "touchmove");
        }
        function __accumulateOffset(node, parentProperty, property) {
            var left = property + 'Left';
            var top = property + 'Top';
            var x = 0, y = 0, style;
            while (isIOS &amp;&amp; node &amp;&amp; node.style) {
                if (node.currentStyle) {
                    style = node.currentStyle.position;
                }
                else {
                    style = (node.ownerDocument.defaultView || node.ownerDocument.parentWindow).getComputedStyle(node, null);
                    style = style ? style.getPropertyValue('position') : null;
                }
                if (!/^(fixed)$/.test(style)) {
                    x += node[left];
                    y += node[top];
                    node = node[parentProperty];
                }
                else {
                    break;
                }
            }
            return {
                x: x,
                y: y,
                style: style
            };
        }
        /**
         * Get a DOM node offset based on its position attribute.
         * @param node {HTMLElement}
         * @returns {cc.math.Point}
         * @private
         */
        function __getOffset(node) {
            var res = __accumulateOffset(node, 'offsetParent', 'offset');
            if (res.style === 'fixed') {
                var res2 = __accumulateOffset(node, node.parentNode ? 'parentNode' : 'parentElement', 'scroll');
                return {
                    x: res.x + res2.x,
                    y: res.y + res2.y
                };
            }
            return {
                x: res.x,
                y: res.y
            };
        }
        /**
         * This function tansforms a window-space input coordinate event into a _target-space coordinate.
         * Modern browsers have a getBoundingClientRect for this purpose, but older don't so a more complex mechanism for
         * finding out the coordinate is deployed.
         * This includes logic based on the position style of the canvas, screen scroll, etc., and some other perks.
         *
         * It surely does not cover corner or weird cases !!!.
         *
         * It also stores the _screenPoint value.
         *
         * @param point {cc.math.Point} an output point.
         * @param e {MouseEvent}
         */
        function getTargetSpacePoint(point, e) {
            _screenPoint.x = e.clientX;
            _screenPoint.y = e.clientY;
            var posx = 0;
            var posy = 0;
            if (navigator.isCocoonJS) {
                posx = e.pageX;
                posy = e.pageY;
            }
            else if (typeof e.offsetX !== "undefined" || typeof e.layerX !== "undefined" || typeof e.clientX !== "undefined") {
                var bcr = _target.getBoundingClientRect();
                posx = e.clientX; // || e.offsetX || e.layerX;
                posy = e.clientY; // || e.offsetY || e.layerY;
                posx = (posx - bcr.left) * (_target.width / bcr.width);
                posy = (posy - bcr.top) * (_target.height / bcr.height);
            }
            else {
                /**
                 * older browsers.
                 * survival model. try to find things on your own by traversing upwards the DOM tree.
                 */
                if (!e)
                    e = window.event;
                if (e.pageX || e.pageY) {
                    posx = e.pageX;
                    posy = e.pageY;
                }
                else if (e.clientX || e.clientY) {
                    posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                    posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                }
                var offset = __getOffset(this.canvas);
                posx -= offset.x;
                posy -= offset.y;
            }
            _targetPoint.set(posx, posy);
            point.set(posx, posy);
        }
        /**
         * @class cc.input.MouseInputManagerEvent
         * @extends cc.input.InputManagerEvent
         * @classdesc
         *
         * This class represents information for a Mouse-level event and translated into CocosJS needed information.
         *
         */
        var MouseInputManagerEvent = (function (_super) {
            __extends(MouseInputManagerEvent, _super);
            /**
             * Create a new MouseInputManagerEvent instance.
             * @method cc.input.MouseInputManagerEvent#constructor
             * @param e {MouseEvent} DOM level original event.
             */
            function MouseInputManagerEvent(e) {
                _super.call(this);
                /**
                 * Original DOM level event that triggered this MouseInputManagerEvent
                 * @member cc.input.MouseInputManagerEvent#_originalDOMEvent
                 * @type {MouseEvent}
                 * @private
                 */
                this._originalDOMEvent = null;
                /**
                 * position in canvas space.
                 * @member cc.input.MouseInputManagerEvent#_screenPoint
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._screenPoint = null;
                /**
                 * Target Node local coordinate.
                 * @member cc.input.MouseInputManagerEvent#_screenPoint
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._localPoint = null;
                /**
                 * For a dragging operation, position in canvas space of the previous event.
                 * @member cc.input.MouseInputManagerEvent#_screenPoint
                 * @type {cc.math.Vector}
                 * @private
                 */
                this._prevScreenPoint = null;
                this._originalDOMEvent = e;
                this._screenPoint = new Vector();
                this._localPoint = new Vector();
                this._prevScreenPoint = new Vector();
            }
            MouseInputManagerEvent.prototype.getDelta = function () {
                return {
                    x: this._screenPoint.x - this._prevScreenPoint.x,
                    y: this._screenPoint.y - this._prevScreenPoint.y
                };
            };
            /**
             * Set this event's screen point.
             * @method cc.input.MouseInputManagerEvent#setScreenPoint
             * @param x {number}
             * @param y {number}
             */
            MouseInputManagerEvent.prototype.setScreenPoint = function (x, y) {
                this._screenPoint.set(x, y);
            };
            /**
             * Initialize the event for type and target.
             * @method cc.input.MouseInputManagerEvent#initializeEventForTarget
             * @param target {cc.node.Node}
             * @param event {string}
             */
            MouseInputManagerEvent.prototype.initializeEventForTarget = function (target, event) {
                _super.prototype.initializeEventForTarget.call(this, target, event);
                this._localPoint.set(this._screenPoint.x, this._screenPoint.y);
            };
            Object.defineProperty(MouseInputManagerEvent.prototype, "localPoint", {
                /**
                 * Get target Node's local coordinate where the event originated.
                 * @method cc.input.MouseInputManagerEvent#get:localPoint
                 * @returns {cc.math.Vector}
                 */
                get: function () {
                    return this._localPoint;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MouseInputManagerEvent.prototype, "prevScreenPoint", {
                /**
                 * Get target screen coordinate where the previous event originated.
                 * @method cc.input.MouseInputManagerEvent#get:prevScreenPoint
                 * @returns {cc.math.Vector}
                 */
                get: function () {
                    return this._prevScreenPoint;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MouseInputManagerEvent.prototype, "screenPoint", {
                /**
                 * Get target screen coordinate where the event originated.
                 * @method cc.input.MouseInputManagerEvent#get:screenPoint
                 * @returns {cc.math.Vector}
                 */
                get: function () {
                    return this._screenPoint;
                },
                enumerable: true,
                configurable: true
            });
            return MouseInputManagerEvent;
        })(InputManagerEvent);
        input.MouseInputManagerEvent = MouseInputManagerEvent;
        /**
         * @class cc.input.MouseInputManager
         * @classdesc
         *
         * This object is CocosJS system general mouse/touch input manager.
         * Mouse events are registered at window level. This will prevent from stop receiving input events if the mouse/touch
         * gets out of the canvas area, but on the other hand, it will impose a more complicated local canvas coordinate
         * matching for older browsers.
         *
         * It is a non-instantiable object, and a call to enable/disable, like to any other system-wide input event must
         * be performed before receiving input events.
         *
         * Touch events are mapped as follows:
         *
         *  &lt;li>touch start -> mousedown
         *  &lt;li>touch end   -> mouseup
         *  &lt;li>touch move  -> mousedrag
         *
         * There's no need to register specific listeners for the touch events. If a corresponding mouse event is registered
         * it will be notified on these instead.
         *
         */
        var MouseInputManager = (function () {
            function MouseInputManager() {
            }
            /**
             * Set the scene to route input events to.
             * This happens automatically at director level whenever a call to runAction happens.
             * @method cc.input.MouseInputManager.enableInputForScene
             * @param scene {cc.node.Scene}
             */
            MouseInputManager.enableInputForScene = function (scene) {
                _scene = scene;
            };
            MouseInputManager.disableInputForScene = function () {
                _scene = null;
            };
            /**
             * Enable the input for mouse and touch.
             * @method cc.input.MouseInputManager.enable
             * @param target {HTMLCanvasElement} canvas target.
             */
            MouseInputManager.enable = function (target) {
                if (_target !== null) {
                    this.disable();
                }
                _target = target;
                window.addEventListener('mouseup', mouseUp, false);
                window.addEventListener('mousedown', mouseDown, false);
                window.addEventListener('mouseover', mouseOver, false);
                window.addEventListener('mouseout', mouseOut, false);
                window.addEventListener('mousemove', mouseMove, false);
                window.addEventListener('dblclick', doubleClick, false);
                target.addEventListener("touchstart", touchStart, false);
                target.addEventListener("touchmove", touchMove, false);
                target.addEventListener("touchend", touchEnd, false);
            };
            /**
             * Disable the input for mouse and touch.
             * @method cc.input.MouseInputManager.disable
             */
            MouseInputManager.disable = function () {
                if (_target !== null) {
                    window.removeEventListener('mouseup', mouseUp, false);
                    window.removeEventListener('mousedown', mouseDown, false);
                    window.removeEventListener('mouseover', mouseOver, false);
                    window.removeEventListener('mouseout', mouseOut, false);
                    window.removeEventListener('mousemove', mouseMove, false);
                    window.removeEventListener('dblclick', doubleClick, false);
                    _target.removeEventListener("touchstart", touchStart, false);
                    _target.removeEventListener("touchmove", touchMove, false);
                    _target.removeEventListener("touchend", touchEnd, false);
                    _target = null;
                }
            };
            return MouseInputManager;
        })();
        input.MouseInputManager = MouseInputManager;
    })(input = cc.input || (cc.input = {}));
})(cc || (cc = {}));
</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					@hyperandroid
					<br />
					
					
		<span class="copyright">
		Chukong inc. 2014
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on 23/Tu/2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
