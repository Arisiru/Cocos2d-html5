<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CocosJS Source: plugin/layout/LayoutManager.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CocosJS</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#cc">cc</a>
						</li>
						
						<li>
							<a href="global.html#cc#action">cc.action</a>
						</li>
						
						<li>
							<a href="cc.Debug.html">cc.Debug</a>
						</li>
						
						<li>
							<a href="cc.game.html">cc.game</a>
						</li>
						
						<li>
							<a href="cc.input.html">cc.input</a>
						</li>
						
						<li>
							<a href="cc.locale.html">cc.locale</a>
						</li>
						
						<li>
							<a href="cc.math.html">cc.math</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html">cc.math.path</a>
						</li>
						
						<li>
							<a href="cc.node.html">cc.node</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.html">cc.node.sprite</a>
						</li>
						
						<li>
							<a href="cc.plugin.html">cc.plugin</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.html">cc.plugin.asset</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.html">cc.plugin.audio</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.html">cc.plugin.layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.html">cc.plugin.loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.html">cc.plugin.texture</a>
						</li>
						
						<li>
							<a href="cc.render.html">cc.render</a>
						</li>
						
						<li>
							<a href="cc.render.shader.html">cc.render.shader</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLState.html">cc.render.WebGLState</a>
						</li>
						
						<li>
							<a href="cc.transition.html">cc.transition</a>
						</li>
						
						<li>
							<a href="cc.util.html">cc.util</a>
						</li>
						
						<li>
							<a href="cc.widget.html">cc.widget</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cc.action.Action.html">cc.action.Action</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext.html">cc.action.ActionChainContext</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext_constructor.html">cc.action.ActionChainContext#constructor</a>
						</li>
						
						<li>
							<a href="cc.action.ActionInfo.html">cc.action.ActionInfo</a>
						</li>
						
						<li>
							<a href="cc.action.ActionManager.html">cc.action.ActionManager</a>
						</li>
						
						<li>
							<a href="cc.action.AlphaAction.html">cc.action.AlphaAction</a>
						</li>
						
						<li>
							<a href="cc.action.AnimateAction.html">cc.action.AnimateAction</a>
						</li>
						
						<li>
							<a href="cc.action.Interpolator.html">cc.action.Interpolator</a>
						</li>
						
						<li>
							<a href="cc.action.JumpAction.html">cc.action.JumpAction</a>
						</li>
						
						<li>
							<a href="cc.action.MoveAction.html">cc.action.MoveAction</a>
						</li>
						
						<li>
							<a href="cc.action.ParseInterpolator.html">cc.action.ParseInterpolator</a>
						</li>
						
						<li>
							<a href="cc.action.PathAction.html">cc.action.PathAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyAction.html">cc.action.PropertyAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyInfo.html">cc.action.PropertyInfo</a>
						</li>
						
						<li>
							<a href="cc.action.RotateAction.html">cc.action.RotateAction</a>
						</li>
						
						<li>
							<a href="cc.action.ScaleAction.html">cc.action.ScaleAction</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueue.html">cc.action.SchedulerQueue</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueueTask.html">cc.action.SchedulerQueueTask</a>
						</li>
						
						<li>
							<a href="cc.action.SequenceAction.html">cc.action.SequenceAction</a>
						</li>
						
						<li>
							<a href="cc.action.TintAction.html">cc.action.TintAction</a>
						</li>
						
						<li>
							<a href="cc.game.Game.html">cc.game.Game</a>
						</li>
						
						<li>
							<a href="cc.input.InputManager.html">cc.input.InputManager</a>
						</li>
						
						<li>
							<a href="cc.input.InputManagerEvent.html">cc.input.InputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.KeyActionInfo.html">cc.input.KeyActionInfo</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardCursor.html">cc.input.KeyboardCursor</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardInputManager.html">cc.input.KeyboardInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.KeyInfo.html">cc.input.KeyInfo</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManager.html">cc.input.MouseInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManagerEvent.html">cc.input.MouseInputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.PriorityInputNode.html">cc.input.PriorityInputNode</a>
						</li>
						
						<li>
							<a href="cc.input.SceneGraphInputTreeNode.html">cc.input.SceneGraphInputTreeNode</a>
						</li>
						
						<li>
							<a href="cc.math.Color.html">cc.math.Color</a>
						</li>
						
						<li>
							<a href="cc.math.Dimension.html">cc.math.Dimension</a>
						</li>
						
						<li>
							<a href="cc.math.Matrix3.html">cc.math.Matrix3</a>
						</li>
						
						<li>
							<a href="cc.math.Path.html">cc.math.Path</a>
						</li>
						
						<li>
							<a href="cc.math.path.ContainerSegment.html">cc.math.path.ContainerSegment</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentArc.html">cc.math.path.SegmentArc</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentBezier.html">cc.math.path.SegmentBezier</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentCardinalSpline.html">cc.math.path.SegmentCardinalSpline</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html#SegmentLine">cc.math.path.SegmentLine</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentQuadratic.html">cc.math.path.SegmentQuadratic</a>
						</li>
						
						<li>
							<a href="cc.math.path.SubPath.html">cc.math.path.SubPath</a>
						</li>
						
						<li>
							<a href="cc.math.Rectangle.html">cc.math.Rectangle</a>
						</li>
						
						<li>
							<a href="cc.math.Vector.html">cc.math.Vector</a>
						</li>
						
						<li>
							<a href="cc.node.Director.html">cc.node.Director</a>
						</li>
						
						<li>
							<a href="cc.node.FastSprite.html">cc.node.FastSprite</a>
						</li>
						
						<li>
							<a href="cc.node.Node.html">cc.node.Node</a>
						</li>
						
						<li>
							<a href="cc.node.Scene.html">cc.node.Scene</a>
						</li>
						
						<li>
							<a href="cc.node.Sprite_.html">cc.node.Sprite</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.Animation.html">cc.node.sprite.Animation</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.AnimationCache.html">cc.node.sprite.AnimationCache</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.SpriteFrame.html">cc.node.sprite.SpriteFrame</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.AssetManager.html">cc.plugin.asset.AssetManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioEffect.html">cc.plugin.audio.AudioEffect</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioManager.html">cc.plugin.audio.AudioManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.FontMetrics.html">cc.plugin.font.FontMetrics</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFont.html">cc.plugin.font.SpriteFont</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFontChar.html">cc.plugin.font.SpriteFontChar</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.BorderLayout.html">cc.plugin.layout.BorderLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Gap.html">cc.plugin.layout.Gap</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.GridLayout.html">cc.plugin.layout.GridLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Insets.html">cc.plugin.layout.Insets</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.LayerLayout.html">cc.plugin.layout.LayerLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Layout.html">cc.plugin.layout.Layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Unit.html">cc.plugin.layout.Unit</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.Loader.html">cc.plugin.loader.Loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderAudioBuffer.html">cc.plugin.loader.ResourceLoaderAudioBuffer</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderImage.html">cc.plugin.loader.ResourceLoaderImage</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderJSON.html">cc.plugin.loader.ResourceLoaderJSON</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderXML.html">cc.plugin.loader.ResourceLoaderXML</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePacker.html">cc.plugin.texture.TexturePacker</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerNode.html">cc.plugin.texture.TexturePackerNode</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerPage.html">cc.plugin.texture.TexturePackerPage</a>
						</li>
						
						<li>
							<a href="cc.render.CanvasRenderer.html">cc.render.CanvasRenderer</a>
						</li>
						
						<li>
							<a href="cc.render.DecoratedWebGLRenderingContext.html">cc.render.DecoratedWebGLRenderingContext</a>
						</li>
						
						<li>
							<a href="cc.render.GeometryBatcher.html">cc.render.GeometryBatcher</a>
						</li>
						
						<li>
							<a href="cc.render.Pattern.html">cc.render.Pattern</a>
						</li>
						
						<li>
							<a href="cc.render.Renderer.html">cc.render.Renderer</a>
						</li>
						
						<li>
							<a href="cc.render.RenderingContextSnapshot.html">cc.render.RenderingContextSnapshot</a>
						</li>
						
						<li>
							<a href="cc.render.ScaleManager.html">cc.render.ScaleManager</a>
						</li>
						
						<li>
							<a href="cc.render.shader.AbstractShader.html">cc.render.shader.AbstractShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Attribute.html">cc.render.shader.Attribute</a>
						</li>
						
						<li>
							<a href="cc.render.shader.MatrixUniform.html">cc.render.shader.MatrixUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.SolidColorShader.html">cc.render.shader.SolidColorShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureShader.html">cc.render.shader.TextureShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureUniform.html">cc.render.shader.TextureUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Uniform.html">cc.render.shader.Uniform</a>
						</li>
						
						<li>
							<a href="cc.render.Texture2D.html">cc.render.Texture2D</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLRenderer.html">cc.render.WebGLRenderer</a>
						</li>
						
						<li>
							<a href="cc.transition.Transition.html">cc.transition.Transition</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionFade.html">cc.transition.TransitionFade</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionMove.html">cc.transition.TransitionMove</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInB.html">cc.transition.TransitionSlideInB</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInL.html">cc.transition.TransitionSlideInL</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInR.html">cc.transition.TransitionSlideInR</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInT.html">cc.transition.TransitionSlideInT</a>
						</li>
						
						<li>
							<a href="cc.util.Resource.html">cc.util.Resource</a>
						</li>
						
						<li>
							<a href="cc.widget.Button.html">cc.widget.Button</a>
						</li>
						
						<li>
							<a href="cc.widget.Label.html">cc.widget.Label</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#__extends">__extends</a>
						</li>
						
						<li>
							<a href="global.html#test">test</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: plugin/layout/LayoutManager.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/**
 * License: see license.txt file.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// &lt;reference path="../../math/Rectangle.ts"/>
/// &lt;reference path="../../math/Dimension.ts"/>
var cc;
(function (cc) {
    var plugin;
    (function (plugin) {
        var layout;
        (function (_layout) {
            /**
             * @class cc.plugin.layout.Unit
             * @classdesc
             *
             * This class encapsulates a value in a given unit.
             * Currently, it could be a number, or a percentage value.
             * If the value is a percentage, a call to &lt;code>getValue&lt;/code> needs a reference value.
             */
            var Unit = (function () {
                /**
                 * Create a new Unit object instance.
                 * @method cc.plugin.layout.Unit#constructor
                 * @param original {string=} Unit value. if not set, the unit it set to 0.
                 */
                function Unit(original) {
                    /**
                     * Unit value.
                     * @member cc.plugin.layout.Unit#_orgValue
                     * @type {number}
                     * @private
                     */
                    this._orgValue = 0;
                    /**
                     * Unit type. Either px, %, or nothing.
                     * @member cc.plugin.layout.Unit#_orgType
                     * @type {string}
                     * @private
                     */
                    this._orgType = "";
                    if (typeof original !== 'undefined') {
                        this.setValue(original);
                    }
                }
                /**
                 * Set the unit value. For example '2%', '100px', '100'
                 * @method cc.plugin.layout.Unit#setValue
                 * @param original {string}
                 */
                Unit.prototype.setValue = function (original) {
                    var exp = new RegExp("\\d+\\.?\\d*(.*)", "gi");
                    var m = exp.exec("" + original);
                    if (m) {
                        this._orgType = m[1];
                        this._orgValue = parseInt(m[0]);
                    }
                };
                /**
                 * Get the unit value.
                 * If the unit type is percentage, and no reference value is supplied, zero will be returned as value.
                 * @method cc.plugin.layout.Unit#getValue
                 * @param ref {number=} percentage reference value.
                 * @returns {number}
                 */
                Unit.prototype.getValue = function (ref) {
                    switch (this._orgType) {
                        case "":
                            return this._orgValue;
                        case "px":
                            return this._orgValue;
                        case "%":
                            return typeof ref !== "undefined" ? this._orgValue / 100 * ref : 0;
                    }
                };
                return Unit;
            })();
            _layout.Unit = Unit;
            /**
             * @class cc.plugin.layout.Insets
             * @classdesc
             *
             * This class describes a layout element internal padding.
             * It is descibed as independent inset values for top, bottom, left and right.
             * These values are Unit objects, so can be described as percentage values. The relative values are relative to
             * the Layout element assigned dimension, so its calculation is deferred to the proper layout stage.
             */
            var Insets = (function () {
                function Insets() {
                    /**
                     * Layout element left inset Unit.
                     * @member cc.plugin.layout.Insets#left
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.left = new Unit();
                    /**
                     * Layout element top inset Unit.
                     * @member cc.plugin.layout.Insets#top
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.top = new Unit();
                    /**
                     * Layout element right inset Unit.
                     * @member cc.plugin.layout.Insets#right
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.right = new Unit();
                    /**
                     * Layout element bottom inset Unit.
                     * @member cc.plugin.layout.Insets#bottom
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.bottom = new Unit();
                }
                return Insets;
            })();
            _layout.Insets = Insets;
            /**
             * @class cc.plugin.layout.Gap
             * @classdesc
             *
             * This object describes the separation values between two adjacent layout elements.
             * For example, for a grid, describes the Units to separate the grid elements.
             */
            var Gap = (function () {
                function Gap() {
                    /**
                     * Horizontal gap Unit.
                     * @member cc.plugin.layout.Gap#horizontal
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.horizontal = new Unit();
                    /**
                     * Vertical gap Unit.
                     * @member cc.plugin.layout.Gap#vertical
                     * @type {cc.plugin.layout.Unit}
                     */
                    this.vertical = new Unit();
                }
                return Gap;
            })();
            _layout.Gap = Gap;
            /**
             * @class cc.plugin.layout.Layout
             * @classdesc
             *
             * This object is the base for all other layout objects.
             * The layout will assign bounds (position and size) for all the layout elements it contains.
             * Layouts will apply different space partitioning rules to conform elements to available space.
             * Layout elements can be nested. for example, a grid cell can contain another grid of elements.
             * &lt;p>
             * Each layout element will have its bounds modified by an &lt;code>Insets&lt;/code> object which will reduce the
             * available element bounds.
             * Some layout types, like &lt;code>GridLayout&lt;/code> or &lt;code>BorderLayout&lt;/code> will be able to apply a gap
             * to separate the contained elements.
             * &lt;p>
             * A layout element can define a preferred size (either in units or percentage) to layout with. This value is
             * needed for layout types that don't impose a size constraint. For example, a GridLayout will set each element's
             * bounds with a fixed rule, that is, dividing the space evenly. But others, like a BorderLayout won't, so you
             * must hint how much space each element is expected to take.
             * &lt;p>
             *     Layouts are defined declaratively and a Node or any other object, does not need to know anything about
             *     the layout itself.
             * &lt;p>
             * The BaseLayout object assumes no children when laying out. Other extending objects will modify this behavior.
             */
            var BaseLayout = (function () {
                /**
                 * Create a new BaseLayout object instance.
                 * Do not create directly, only by subclasses.
                 * @method cc.plugin.layout.BaseLayout#constructor
                 */
                function BaseLayout() {
                    /**
                     * Resulting bounds after applying the layout rules.
                     * @member cc.plugin.layout.BaseLayout#_bounds
                     * @type {cc.math.Rectangle}
                     * @private
                     */
                    this._bounds = null;
                    /**
                     * The layout insets. Insets will reduce the bounds area by setting a padding for the element.
                     * @member cc.plugin.layout.BaseLayout#_insets
                     * @type {cc.plugin.layout.Insets}
                     * @private
                     */
                    this._insets = null;
                    /**
                     * Separation between each layout elements. Not all layout will use this value.
                     * @member cc.plugin.layout.BaseLayout#_gap
                     * @type {cc.plugin.layout.Gap}
                     * @private
                     */
                    this._gap = null;
                    /**
                     * Array of elements to lay out. Since layouts are nestable, children are layout instances as well.
                     * @member cc.plugin.layout.BaseLayout#_children
                     * @type {Array&lt;cc.plugin.layout.BaseLayout>}
                     * @private
                     */
                    this._children = [];
                    /**
                     * Layout preferred width Unit hint.
                     * @member cc.plugin.layout.BaseLayout#_preferredWidth
                     * @type {cc.plugin.layout.Unit}
                     * @private
                     */
                    this._preferredWidth = null;
                    /**
                     * Layout preferred height Unit hint.
                     * @member cc.plugin.layout.BaseLayout#_preferredHeight
                     * @type {cc.plugin.layout.Unit}
                     * @private
                     */
                    this._preferredHeight = null;
                    /**
                     * Optional layout identifier.
                     * This is useful so that a node tag or name can be matched against this layout element.
                     * @member cc.plugin.layout.BaseLayout#_name
                     * @type {string}
                     * @private
                     */
                    this._name = '';
                    this._bounds = new cc.math.Rectangle();
                    this._insets = new Insets();
                    this._gap = new Gap();
                    this._preferredWidth = new Unit();
                    this._preferredHeight = new Unit();
                }
                /**
                 * Parse a layout initializer object to get a layout element object.
                 * @param layout {string|cc.plugin.layout.BaseLayoutInitializer} a layout initializer object, or a string.
                 *   If a string is set, a BaseLayout object will be used.
                 */
                BaseLayout.parse = function (layout) {
                    if (typeof layout === "string") {
                        return new BaseLayout().parse({
                            type: 'element',
                            name: layout
                        });
                    }
                    else if (layout.type === "element") {
                        return new BaseLayout().parse(layout);
                    }
                    else if (layout.type === "border") {
                        return new BorderLayout().parse(layout);
                    }
                    else if (layout.type === "layer") {
                        return new LayerLayout().parse(layout);
                    }
                    else if (layout.type === "grid") {
                        return new GridLayout().parse(layout);
                    }
                    else {
                        console.log("unknown layout type: " + layout.type);
                    }
                };
                /**
                 * Helper method to visually see the layout result.
                 * @method cc.plugin.layout.BaseLayout#paint
                 * @param ctx {CanvasRenderingContext2D}
                 */
                BaseLayout.prototype.paint = function (ctx) {
                    //ctx.setTransform(1,0,0,1,0,0);
                    ctx.strokeRect(this._bounds.x, this._bounds.y, this._bounds.w, this._bounds.h);
                    for (var i = 0; i &lt; this._children.length; i++) {
                        this._children[i].paint(ctx);
                    }
                };
                /**
                 * Set the layout bounds.
                 * @method cc.plugin.layout.BaseLayout#setBounds
                 * @param x {number}
                 * @param y {number}
                 * @param w {number}
                 * @param h {number}
                 */
                BaseLayout.prototype.setBounds = function (x, y, w, h) {
                    this._bounds.set(x, y, w, h);
                };
                /**
                 * Set the layout size.
                 * @method cc.plugin.layout.BaseLayout#setSize
                 * @param w {number}
                 * @param h {number}
                 */
                BaseLayout.prototype.setSize = function (w, h) {
                    this._bounds.w = w;
                    this._bounds.h = h;
                };
                /**
                 * Set the layout preferred size Unit hints.
                 * @param w {number|string}
                 * @param h {number|string}
                 */
                BaseLayout.prototype.setPreferredSize = function (w, h) {
                    this._preferredWidth.setValue(w);
                    this._preferredHeight.setValue(h);
                };
                /**
                 * Get the element preferredSize.
                 * The size units are evaluated, so if they are percentage, the value is recalculated now again.
                 * @method cc.plugin.layout.BaseLayout#getPreferredSize
                 * @returns {cc.math.Dimension}
                 */
                BaseLayout.prototype.getPreferredSize = function () {
                    return new cc.math.Dimension(this._preferredWidth.getValue(this._bounds.w), this._preferredHeight.getValue(this._bounds.h));
                };
                /**
                 * Recursively evaluate the layout elements and get the resulting preferred size.
                 * This does not take into account the size constraints, will get the desired size.
                 * In this object, the implementation returns the result of the preferredSize Unit hints + Insets.
                 * @method cc.plugin.layout.BaseLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                BaseLayout.prototype.getPreferredLayoutSize = function () {
                    var ps = this.getPreferredSize();
                    this.adjustWithInsets(ps);
                    return ps;
                };
                /**
                 * Evaluate the layout with the current size constraints. The root layout element bounds will be used
                 * as size constraint.
                 * @method cc.plugin.layout.BaseLayout#doLayout
                 */
                BaseLayout.prototype.doLayout = function () {
                    var d = new cc.math.Dimension();
                    this.adjustWithInsets(d);
                    this._bounds.w -= d.width;
                    this._bounds.h -= d.height;
                    this._bounds.x += d.width / 2;
                    this._bounds.y += d.height / 2;
                };
                /**
                 * Set size constraints and evaluate the layout.
                 * The result will be all layout elements have assigned a bounds.
                 * @method cc.plugin.layout.BaseLayout#layout
                 * @param x {number}
                 * @param y {number}
                 * @param w {number}
                 * @param h {number}
                 */
                BaseLayout.prototype.layout = function (x, y, w, h) {
                    this.setBounds(x, y, w, h);
                    this.doLayout();
                };
                /**
                 * Parse a layout definition object.
                 * This will get all the common layout properties: insets, gap, preferred size and elements.
                 * @method cc.plugin.layout.BaseLayout#parse
                 * @param layoutInfo {cc.plugin.layout.BaseLayoutInitializer}
                 * @returns {cc.plugin.layout.BaseLayout}
                 */
                BaseLayout.prototype.parse = function (layoutInfo) {
                    if (typeof layoutInfo.insets !== 'undefined') {
                        var arr = layoutInfo.insets;
                        if (arr.length !== 4) {
                            console.log("wrong defined insets: " + arr);
                        }
                        this._insets.left.setValue(layoutInfo.insets[0]);
                        this._insets.right.setValue(layoutInfo.insets[2]);
                        this._insets.top.setValue(layoutInfo.insets[1]);
                        this._insets.bottom.setValue(layoutInfo.insets[3]);
                    }
                    if (typeof layoutInfo.gap !== 'undefined') {
                        var arr = layoutInfo.gap;
                        if (arr.length !== 2) {
                            console.log("wrong defined gap: " + arr);
                        }
                        this._gap.horizontal.setValue(layoutInfo.gap[0]);
                        this._gap.vertical.setValue(layoutInfo.gap[1]);
                    }
                    if (typeof layoutInfo.preferredWidth !== 'undefined') {
                        this._preferredWidth.setValue(layoutInfo.preferredWidth);
                    }
                    if (typeof layoutInfo.preferredHeight !== 'undefined') {
                        this._preferredHeight.setValue(layoutInfo.preferredHeight);
                    }
                    if (typeof layoutInfo.name !== 'undefined') {
                        this._name = layoutInfo.name;
                    }
                    if (typeof layoutInfo.elements !== 'undefined') {
                        if (Object.prototype.toString.call(layoutInfo.elements) === '[object Array]') {
                            this.parseElements(layoutInfo.elements);
                        }
                        else {
                            console.log("Layout elememts block is not array.");
                        }
                    }
                    return this;
                };
                /**
                 * Parse the elements block from the layout initializer object.
                 * @method cc.plugin.layout.BaseLayout#parseElements
                 * @param children {Array&lt;object>}
                 */
                BaseLayout.prototype.parseElements = function (children) {
                    var me = this;
                    function addElement(s) {
                        var elem = cc.plugin.layout.BaseLayout.parse(s);
                        if (elem) {
                            me._children.push(elem);
                        }
                        else {
                        }
                    }
                    for (var i = 0; i &lt; children.length; i++) {
                        if (typeof children[i] === 'string') {
                            var elem = children[i];
                            // is elem of the form text[...] ?
                            if (elem.indexOf('[') !== -1 &amp;&amp; elem.indexOf(']') !== -1) {
                                var exp = new RegExp("(.*)\\[(.*)\\]", "gi");
                                var m = exp.exec(elem);
                                var prefix = m[1];
                                var pattern = m[2].split('-');
                                if (pattern.length === 2) {
                                    var from = parseInt(pattern[0]);
                                    var to = parseInt(pattern[1]);
                                    while (from &lt;= to) {
                                        addElement(prefix + from);
                                        from++;
                                    }
                                }
                                else {
                                    /// wrong pattern ?!?!?!?!?
                                    console.log("wrong pattern for element by name: " + elem);
                                    addElement(elem);
                                }
                            }
                            else {
                                // not name pattern.
                                addElement(elem);
                            }
                        }
                        else {
                            addElement(children[i]);
                        }
                    }
                };
                /**
                 * Add an element layout to this layout object.
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @param constraint {string=} a constraint to add an element. For example, BorderLayout requires a position hint
                 *      to add an element.
                 */
                BaseLayout.prototype.addElement = function (e, constraint) {
                    this._children.push(e);
                };
                /**
                 * Helper method to add the Inset object value to a Dimension.
                 * @method cc.plugin.layout.BaseLayout#adjustWithInsets
                 * @param d
                 */
                BaseLayout.prototype.adjustWithInsets = function (d) {
                    d.width += this._insets.left.getValue(this._bounds.w) + this._insets.right.getValue(this._bounds.w);
                    d.height += this._insets.top.getValue(this._bounds.h) + this._insets.bottom.getValue(this._bounds.h);
                };
                /**
                 * Recursively traverse the layout elements and, if a layout element has name, find a node with that name
                 * and then set the found node's position to the layout calculated position. If resize is set to true,
                 * the found node's content size will be set to the layout calculated size.
                 * The node is searched in the _node parameter or any of its children.
                 * @param _node {cc.node.Node} the node to traverse to find a node with a layout name
                 * @param resize {boolean} change de node size to that of the calculated layout ?
                 */
                BaseLayout.prototype.applyToNode = function (_node, resize) {
                    var _this = this;
                    if (!_node) {
                        return;
                    }
                    if (this._name !== "") {
                        _node.enumerateChildren(this._name, function (node) {
                            node.setPosition(_this._bounds.x, _this._bounds.y);
                            if (resize) {
                                node.setContentSize(_this._bounds.w, _this._bounds.h);
                            }
                        });
                    }
                    for (var i = 0; i &lt; this._children.length; i++) {
                        this._children[i].applyToNode(_node, resize);
                    }
                };
                return BaseLayout;
            })();
            _layout.BaseLayout = BaseLayout;
            /**
             * @class cc.plugin.layout.BorderLayout
             * @extends cc.plugin.layout.BaseLayout
             * @classdesc
             *
             * A BorderLayout object divides the available space in up to 5 different regions as follows:
             * &lt;pre>
             *
             *     +----------------------------+
             *     |            TOP             |
             *     +------+-------------+-------+
             *     | LEFT |             | RIGHT |
             *     |      |             |       |
             *     |      |             |       |
             *     |      |   CENTER    |       |
             *     |      |             |       |
             *     |      |             |       |
             *     |      |             |       |
             *     +------+-------------+-------+
             *     |           BOTTOM           |
             *     +----------------------------+
             * &lt;/pre>
             *
             * &lt;p>
             *     Since all bounds are dynamically calculated, elements added to a BorderLayout (at any nesting level) must
             *     have preferred size hints.
             * &lt;p>
             *     The gap values will be empty filler values between every elements. Horizontal between left-center center-right
             *     and vertical betweeen top and bottom and all the others.
             * &lt;p>
             *     All Elements are optional to define.
             * &lt;p>
             *     The center element will get the remaining space after laying out all the other elements.
             *     The left, right and center elements will get the remaining height after evaluating top and then
             *     bottom elements.
             * &lt;p>
             *     top, left, right, bottom and center can be, at the same time, other layouts.
             *
             */
            var BorderLayout = (function (_super) {
                __extends(BorderLayout, _super);
                /**
                 * Build a new BorderLayout object instance
                 * @method cc.plugin.layout.BorderLayout#constructor
                 */
                function BorderLayout() {
                    _super.call(this);
                    /**
                     * Left layout element.
                     * @member cc.plugin.layout.BorderLayout#_left
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._left = null;
                    /**
                     * Right layout element.
                     * @member cc.plugin.layout.BorderLayout#_right
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._right = null;
                    /**
                     * Top layout element.
                     * @member cc.plugin.layout.BorderLayout#_top
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._top = null;
                    /**
                     * Bottom layout element.
                     * @member cc.plugin.layout.BorderLayout#_bottom
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._bottom = null;
                    /**
                     * Center layout element.
                     * @member cc.plugin.layout.BorderLayout#_center
                     * @type {cc.plugin.layout.BaseLayout}
                     * @private
                     */
                    this._center = null;
                }
                /**
                 * Get the preferred layout size after recursively applying the layout. The size will be the preferred size,
                 * not the actual size.
                 * @method cc.plugin.layout.BorderLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                BorderLayout.prototype.getPreferredLayoutSize = function () {
                    var ret = new cc.math.Dimension();
                    var d;
                    if (this._left) {
                        d = this._left.getPreferredLayoutSize();
                        ret.width += d.width + this._gap.horizontal.getValue(this._bounds.w);
                        ret.height = Math.max(d.height, ret.height);
                    }
                    if (this._right) {
                        d = this._right.getPreferredLayoutSize();
                        ret.width += d.width + this._gap.horizontal.getValue(this._bounds.w);
                        ret.height = Math.max(d.height, ret.height);
                    }
                    if (this._center) {
                        d = this._center.getPreferredLayoutSize();
                        ret.width += d.width;
                        ret.height = Math.max(d.height, ret.height);
                    }
                    if (this._top) {
                        d = this._top.getPreferredLayoutSize();
                        ret.height += d.height + this._gap.vertical.getValue(this._bounds.h);
                        ret.width = Math.max(ret.width, d.width);
                    }
                    if (this._bottom) {
                        d = this._bottom.getPreferredLayoutSize();
                        ret.height += d.height + this._gap.vertical.getValue(this._bounds.h);
                        ret.width = Math.max(ret.width, d.width);
                    }
                    this.adjustWithInsets(d);
                    var pd = this.getPreferredSize();
                    d.width = Math.max(d.width, pd.width);
                    d.height = Math.max(d.width, pd.height);
                    return d;
                };
                /**
                 * Set the left layout element.
                 * @method cc.plugin.layout.BorderLayout#left
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.left = function (e) {
                    this._children.push(e);
                    this._left = e;
                    return this;
                };
                /**
                 * Set the right layout element.
                 * @method cc.plugin.layout.BorderLayout#right
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.right = function (e) {
                    this._children.push(e);
                    this._right = e;
                    return this;
                };
                /**
                 * Set the top layout element.
                 * @method cc.plugin.layout.BorderLayout#top
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.top = function (e) {
                    this._children.push(e);
                    this._top = e;
                    return this;
                };
                /**
                 * Set the bottom layout element.
                 * @method cc.plugin.layout.BorderLayout#bottom
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.bottom = function (e) {
                    this._children.push(e);
                    this._bottom = e;
                    return this;
                };
                /**
                 * Set the center layout element.
                 * @method cc.plugin.layout.BorderLayout#center
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.center = function (e) {
                    this._children.push(e);
                    this._center = e;
                    return this;
                };
                /**
                 * Parse the BorderLayout.
                 * @method cc.plugin.layout.BorderLayout#parse
                 * @param layoutInfo {cc.plugin.layout.BorderLayoutInitializer}
                 * @returns {cc.plugin.layout.BorderLayout}
                 */
                BorderLayout.prototype.parse = function (layoutInfo) {
                    _super.prototype.parse.call(this, layoutInfo);
                    if (typeof layoutInfo.left !== "undefined") {
                        this.left(cc.plugin.layout.BaseLayout.parse(layoutInfo.left));
                    }
                    if (typeof layoutInfo.right !== "undefined") {
                        this.right(cc.plugin.layout.BaseLayout.parse(layoutInfo.right));
                    }
                    if (typeof layoutInfo.bottom !== "undefined") {
                        this.bottom(cc.plugin.layout.BaseLayout.parse(layoutInfo.bottom));
                    }
                    if (typeof layoutInfo.top !== "undefined") {
                        this.top(cc.plugin.layout.BaseLayout.parse(layoutInfo.top));
                    }
                    if (typeof layoutInfo.center !== "undefined") {
                        this.center(cc.plugin.layout.BaseLayout.parse(layoutInfo.center));
                    }
                    return this;
                };
                /**
                 * Add an element to the layout. Since this layout only allows for 5 specific elements, an adding constraint
                 * must be used.
                 * @method cc.plugin.layout.BorderLayout#addElement
                 * @param e {cc.plugin.layout.BaseLayout}
                 * @param constraint {string} must exist. a value from 'top','bottom','left','right' or 'center'.
                 */
                BorderLayout.prototype.addElement = function (e, constraint) {
                    if (typeof this[constraint] !== 'undefined') {
                        this[constraint](e);
                    }
                    else {
                        console.log("wrong border layout constraint.");
                    }
                };
                /**
                 * Do the actual lay out process. Elements will fit into the previously set element bounds.
                 * @method cc.plugin.layout.BorderLayout#doLayout
                 */
                BorderLayout.prototype.doLayout = function () {
                    var left = this._bounds.x + this._insets.left.getValue(this._bounds.w);
                    var top = this._bounds.y + this._insets.top.getValue(this._bounds.h);
                    var right = this._bounds.x1 - this._insets.right.getValue(this._bounds.w);
                    var bottom = this._bounds.y1 - this._insets.bottom.getValue(this._bounds.h);
                    var d;
                    if (this._top) {
                        this._top.setSize(right - left, this._top._bounds.h);
                        d = this._top.getPreferredLayoutSize();
                        this._top._bounds.set(left, top, right - left, d.height);
                        this._top.doLayout();
                        top += d.height + this._gap.vertical.getValue(this._bounds.h);
                    }
                    if (this._bottom) {
                        this._bottom.setSize(right - left, this._bottom._bounds.h);
                        d = this._bottom.getPreferredLayoutSize();
                        this._bottom._bounds.set(left, bottom - d.height, right - left, d.height);
                        this._bottom.doLayout();
                        bottom -= d.height + this._gap.vertical.getValue(this._bounds.h);
                    }
                    if (this._right) {
                        this._right.setSize(this._right._bounds.w, bottom - top);
                        d = this._right.getPreferredLayoutSize();
                        this._right._bounds.set(right - d.width, top, d.width, bottom - top);
                        this._right.doLayout();
                        right -= d.width + this._gap.horizontal.getValue(this._bounds.w);
                    }
                    if (this._left) {
                        this._left.setSize(this._left._bounds.w, bottom - top);
                        d = this._left.getPreferredLayoutSize();
                        this._left._bounds.set(left, top, d.width, bottom - top);
                        this._left.doLayout();
                        left += d.width + this._gap.horizontal.getValue(this._bounds.w);
                    }
                    if (this._center) {
                        this._center._bounds.set(left, top, right - left, bottom - top);
                        this._center.doLayout();
                    }
                };
                return BorderLayout;
            })(BaseLayout);
            _layout.BorderLayout = BorderLayout;
            /**
             * @class cc.plugin.layout.GridLayout
             * @extends cc.plugin.layout.BaseLayout
             * @classdesc
             *
             * A grid layout lays elements out either in rows or columns. If rows are specified, the lay out will keep the fixed
             * number of rows and grow on the number of columns or vice versa, like as follows:
             *
             * &lt;pre>
             *
             *     3 rows                        3 columns
             *
             *     +------------+-----...        +----------+----------+----------+
             *     |  row1      |                |   col1   |   col2   |   col3   |
             *     +------------+-----...        +----------+----------+----------+
             *     |  row2      |                |          |          |          |
             *     +------------+-----...        .          .          .          .
             *     |  row3      |                .          .          .          .
             *     +------------+-----...
             * &lt;/pre>
             *
             */
            var GridLayout = (function (_super) {
                __extends(GridLayout, _super);
                /**
                 * Create a new GridLayout object instance.
                 * @method cc.plugin.layout.GridLayout#constructor
                 */
                function GridLayout() {
                    _super.call(this);
                    /**
                     * Lay out in rows or columns.
                     * @member cc.plugin.layout.GridLayout#_layoutRows
                     * @type {boolean}
                     * @private
                     */
                    this._layoutRows = false;
                    /**
                     * Elements to layout before adding a row or column.
                     * @member cc.plugin.layout.GridLayout#_numElements
                     * @type {number}
                     * @private
                     */
                    this._numElements = 0;
                    /**
                     * Calculated number of rows for the current added elements.
                     * @member cc.plugin.layout.GridLayout#_rows
                     * @type {number}
                     * @private
                     */
                    this._rows = 0;
                    /**
                     * Calculated number of columns for the current added elements.
                     * @member cc.plugin.layout.GridLayout#_columns
                     * @type {number}
                     * @private
                     */
                    this._columns = 0;
                }
                /**
                 * Parse the grid info.
                 * @method cc.plugin.layout.GridLayout#parse
                 * @param layoutInfo {cc.plugin.layout.GridLayoutInitializer}
                 * @returns {cc.plugin.layout.GridLayout}
                 */
                GridLayout.prototype.parse = function (layoutInfo) {
                    _super.prototype.parse.call(this, layoutInfo);
                    if (typeof layoutInfo.rows !== 'undefined') {
                        this._layoutRows = true;
                        this._numElements = layoutInfo.rows;
                    }
                    if (typeof layoutInfo.columns !== 'undefined') {
                        this._layoutRows = false;
                        this._numElements = layoutInfo.columns;
                    }
                    if (!this._numElements) {
                        console.log("bug bug grid info wrong defined.");
                    }
                    return this;
                };
                /**
                 * Get the preferred layout elements size. The preferred size will be the adjusted to the biggest element's
                 * preferred size, adding the gap for each of the layout elements.
                 * Finally, the insets will be added to the size.
                 * @method cc.plugin.layout.GridLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                GridLayout.prototype.getPreferredLayoutSize = function () {
                    var rows = 0;
                    var columns = 0;
                    var ret = new cc.math.Dimension();
                    if (this._layoutRows) {
                        rows = this._numElements;
                        columns = ((rows + this._children.length - 1) / rows) >> 0;
                    }
                    else {
                        columns = this._numElements;
                        rows = ((columns + this._children.length - 1) / columns) >> 0;
                    }
                    for (var i = 0; i &lt; this._children.length; i++) {
                        var d = this._children[i].getPreferredLayoutSize();
                        if (d.width > ret.width) {
                            ret.width = d.width;
                        }
                        if (d.height > ret.height) {
                            ret.height = d.height;
                        }
                    }
                    this.adjustWithInsets(d);
                    d.width += columns * ret.width + (columns - 1) * this._gap.horizontal.getValue(this._bounds.w);
                    d.height += rows * ret.height + (rows - 1) * this._gap.vertical.getValue(this._bounds.h);
                    var pd = this.getPreferredSize();
                    d.width = Math.max(d.width, pd.width);
                    d.height = Math.max(d.width, pd.height);
                    this._rows = rows;
                    this._columns = columns;
                    return d;
                };
                /**
                 * Do the actual elements lay out. The size of each element will be constrained to the element's bound.
                 * @method cc.plugin.layout.GridLayout#doLayout
                 */
                GridLayout.prototype.doLayout = function () {
                    if (!this._children.length) {
                        return;
                    }
                    var rows, columns;
                    if (this._layoutRows) {
                        rows = this._numElements;
                        columns = ((rows + this._children.length - 1) / rows) >> 0;
                    }
                    else {
                        columns = this._numElements;
                        rows = ((columns + this._children.length - 1) / columns) >> 0;
                    }
                    this._rows = rows;
                    this._columns = columns;
                    var nrows = this._rows;
                    var ncols = this._columns;
                    var totalGapsWidth = (ncols - 1) * this._gap.horizontal.getValue(this._bounds.w);
                    var widthWOInsets = this._bounds.w - (this._insets.left.getValue(this._bounds.w) + this._insets.right.getValue(this._bounds.w));
                    var widthOnComponent = ((widthWOInsets - totalGapsWidth) / ncols); // floor
                    var extraWidthAvailable = ((widthWOInsets - (widthOnComponent * ncols + totalGapsWidth)) / 2); // floor
                    var totalGapsHeight = (nrows - 1) * this._gap.vertical.getValue(this._bounds.h);
                    var heightWOInsets = this._bounds.h - (this._insets.top.getValue(this._bounds.h) + this._insets.bottom.getValue(this._bounds.h));
                    var heightOnComponent = ((heightWOInsets - totalGapsHeight) / nrows); // floor
                    var extraHeightAvailable = ((heightWOInsets - (heightOnComponent * nrows + totalGapsHeight)) / 2); // floor
                    for (var c = 0, x = this._insets.left.getValue(this._bounds.w) + extraWidthAvailable; c &lt; ncols; c++, x += widthOnComponent + this._gap.horizontal.getValue(this._bounds.w)) {
                        for (var r = 0, y = this._insets.top.getValue(this._bounds.h) + extraHeightAvailable; r &lt; nrows; r++, y += heightOnComponent + this._gap.vertical.getValue(this._bounds.h)) {
                            var i = r * ncols + c;
                            if (i &lt; this._children.length) {
                                var child = this._children[i];
                                if (null !== child) {
                                    child.setBounds(this._bounds.x + x, this._bounds.y + y, widthOnComponent, heightOnComponent);
                                    child.doLayout();
                                }
                            }
                        }
                    }
                };
                return GridLayout;
            })(BaseLayout);
            _layout.GridLayout = GridLayout;
            /**
             * @class cc.plugin.layout.LayerLayout
             * @extends cc.plugin.layout.BaseLayout
             * @classdesc
             *
             * A LayerLayout stacks elements one on top of the other making their bounds the same.
             * The layout does not work on z-index, simply makes them to take over the same area.
             *
             */
            var LayerLayout = (function (_super) {
                __extends(LayerLayout, _super);
                /**
                 * Build a new LayerLayout
                 * @method cc.plugin.layout.LayerLayout#constructor
                 */
                function LayerLayout() {
                    _super.call(this);
                }
                /**
                 * @method cc.plugin.layout.LayerLayout#getPreferredLayoutSize
                 * @returns {cc.math.Dimension}
                 */
                LayerLayout.prototype.getPreferredLayoutSize = function () {
                    var d = new cc.math.Dimension();
                    d.set(this._preferredWidth.getValue(this._bounds.w), this._preferredHeight.getValue(this._bounds.h));
                    this.adjustWithInsets(d);
                    var pd = this.getPreferredSize();
                    d.width = Math.max(d.width, pd.width);
                    d.height = Math.max(d.width, pd.height);
                    return d;
                };
                /**
                 * @method cc.plugin.layout.LayerLayout#doLayout
                 */
                LayerLayout.prototype.doLayout = function () {
                    var x = this._bounds.x + this._insets.left.getValue(this._bounds.w);
                    var y = this._bounds.y + this._insets.top.getValue(this._bounds.h);
                    var w = this._bounds.w - this._insets.left.getValue(this._bounds.w) - this._insets.right.getValue(this._bounds.w);
                    var h = this._bounds.h - this._insets.top.getValue(this._bounds.h) - this._insets.bottom.getValue(this._bounds.h);
                    for (var i = 0; i &lt; this._children.length; i++) {
                        this._children[i].setBounds(x, y, w, h);
                        this._children[i].doLayout();
                    }
                };
                return LayerLayout;
            })(BaseLayout);
            _layout.LayerLayout = LayerLayout;
        })(layout = plugin.layout || (plugin.layout = {}));
    })(plugin = cc.plugin || (cc.plugin = {}));
})(cc || (cc = {}));
</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					@hyperandroid
					<br />
					
					
		<span class="copyright">
		Chukong inc. 2014
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on 23/Tu/2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
