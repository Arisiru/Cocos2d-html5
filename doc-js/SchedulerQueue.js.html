<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CocosJS Source: action/SchedulerQueue.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CocosJS</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#cc">cc</a>
						</li>
						
						<li>
							<a href="global.html#cc#action">cc.action</a>
						</li>
						
						<li>
							<a href="cc.Debug.html">cc.Debug</a>
						</li>
						
						<li>
							<a href="cc.game.html">cc.game</a>
						</li>
						
						<li>
							<a href="cc.input.html">cc.input</a>
						</li>
						
						<li>
							<a href="cc.locale.html">cc.locale</a>
						</li>
						
						<li>
							<a href="cc.math.html">cc.math</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html">cc.math.path</a>
						</li>
						
						<li>
							<a href="cc.node.html">cc.node</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.html">cc.node.sprite</a>
						</li>
						
						<li>
							<a href="cc.plugin.html">cc.plugin</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.html">cc.plugin.asset</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.html">cc.plugin.audio</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.html">cc.plugin.layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.html">cc.plugin.loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.html">cc.plugin.texture</a>
						</li>
						
						<li>
							<a href="cc.render.html">cc.render</a>
						</li>
						
						<li>
							<a href="cc.render.shader.html">cc.render.shader</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLState.html">cc.render.WebGLState</a>
						</li>
						
						<li>
							<a href="cc.transition.html">cc.transition</a>
						</li>
						
						<li>
							<a href="cc.util.html">cc.util</a>
						</li>
						
						<li>
							<a href="cc.widget.html">cc.widget</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cc.action.Action.html">cc.action.Action</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext.html">cc.action.ActionChainContext</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext_constructor.html">cc.action.ActionChainContext#constructor</a>
						</li>
						
						<li>
							<a href="cc.action.ActionInfo.html">cc.action.ActionInfo</a>
						</li>
						
						<li>
							<a href="cc.action.ActionManager.html">cc.action.ActionManager</a>
						</li>
						
						<li>
							<a href="cc.action.AlphaAction.html">cc.action.AlphaAction</a>
						</li>
						
						<li>
							<a href="cc.action.AnimateAction.html">cc.action.AnimateAction</a>
						</li>
						
						<li>
							<a href="cc.action.Interpolator.html">cc.action.Interpolator</a>
						</li>
						
						<li>
							<a href="cc.action.JumpAction.html">cc.action.JumpAction</a>
						</li>
						
						<li>
							<a href="cc.action.MoveAction.html">cc.action.MoveAction</a>
						</li>
						
						<li>
							<a href="cc.action.ParseInterpolator.html">cc.action.ParseInterpolator</a>
						</li>
						
						<li>
							<a href="cc.action.PathAction.html">cc.action.PathAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyAction.html">cc.action.PropertyAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyInfo.html">cc.action.PropertyInfo</a>
						</li>
						
						<li>
							<a href="cc.action.RotateAction.html">cc.action.RotateAction</a>
						</li>
						
						<li>
							<a href="cc.action.ScaleAction.html">cc.action.ScaleAction</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueue.html">cc.action.SchedulerQueue</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueueTask.html">cc.action.SchedulerQueueTask</a>
						</li>
						
						<li>
							<a href="cc.action.SequenceAction.html">cc.action.SequenceAction</a>
						</li>
						
						<li>
							<a href="cc.action.TintAction.html">cc.action.TintAction</a>
						</li>
						
						<li>
							<a href="cc.game.Game.html">cc.game.Game</a>
						</li>
						
						<li>
							<a href="cc.input.InputManager.html">cc.input.InputManager</a>
						</li>
						
						<li>
							<a href="cc.input.InputManagerEvent.html">cc.input.InputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.KeyActionInfo.html">cc.input.KeyActionInfo</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardCursor.html">cc.input.KeyboardCursor</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardInputManager.html">cc.input.KeyboardInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.KeyInfo.html">cc.input.KeyInfo</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManager.html">cc.input.MouseInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManagerEvent.html">cc.input.MouseInputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.PriorityInputNode.html">cc.input.PriorityInputNode</a>
						</li>
						
						<li>
							<a href="cc.input.SceneGraphInputTreeNode.html">cc.input.SceneGraphInputTreeNode</a>
						</li>
						
						<li>
							<a href="cc.math.Color.html">cc.math.Color</a>
						</li>
						
						<li>
							<a href="cc.math.Dimension.html">cc.math.Dimension</a>
						</li>
						
						<li>
							<a href="cc.math.Matrix3.html">cc.math.Matrix3</a>
						</li>
						
						<li>
							<a href="cc.math.Path.html">cc.math.Path</a>
						</li>
						
						<li>
							<a href="cc.math.path.ContainerSegment.html">cc.math.path.ContainerSegment</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentArc.html">cc.math.path.SegmentArc</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentBezier.html">cc.math.path.SegmentBezier</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentCardinalSpline.html">cc.math.path.SegmentCardinalSpline</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html#SegmentLine">cc.math.path.SegmentLine</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentQuadratic.html">cc.math.path.SegmentQuadratic</a>
						</li>
						
						<li>
							<a href="cc.math.path.SubPath.html">cc.math.path.SubPath</a>
						</li>
						
						<li>
							<a href="cc.math.Rectangle.html">cc.math.Rectangle</a>
						</li>
						
						<li>
							<a href="cc.math.Vector.html">cc.math.Vector</a>
						</li>
						
						<li>
							<a href="cc.node.Director.html">cc.node.Director</a>
						</li>
						
						<li>
							<a href="cc.node.FastSprite.html">cc.node.FastSprite</a>
						</li>
						
						<li>
							<a href="cc.node.Node.html">cc.node.Node</a>
						</li>
						
						<li>
							<a href="cc.node.Scene.html">cc.node.Scene</a>
						</li>
						
						<li>
							<a href="cc.node.Sprite_.html">cc.node.Sprite</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.Animation.html">cc.node.sprite.Animation</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.AnimationCache.html">cc.node.sprite.AnimationCache</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.SpriteFrame.html">cc.node.sprite.SpriteFrame</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.AssetManager.html">cc.plugin.asset.AssetManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioEffect.html">cc.plugin.audio.AudioEffect</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioManager.html">cc.plugin.audio.AudioManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.FontMetrics.html">cc.plugin.font.FontMetrics</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFont.html">cc.plugin.font.SpriteFont</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFontChar.html">cc.plugin.font.SpriteFontChar</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.BorderLayout.html">cc.plugin.layout.BorderLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Gap.html">cc.plugin.layout.Gap</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.GridLayout.html">cc.plugin.layout.GridLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Insets.html">cc.plugin.layout.Insets</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.LayerLayout.html">cc.plugin.layout.LayerLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Layout.html">cc.plugin.layout.Layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Unit.html">cc.plugin.layout.Unit</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.Loader.html">cc.plugin.loader.Loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderAudioBuffer.html">cc.plugin.loader.ResourceLoaderAudioBuffer</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderImage.html">cc.plugin.loader.ResourceLoaderImage</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderJSON.html">cc.plugin.loader.ResourceLoaderJSON</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderXML.html">cc.plugin.loader.ResourceLoaderXML</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePacker.html">cc.plugin.texture.TexturePacker</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerNode.html">cc.plugin.texture.TexturePackerNode</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerPage.html">cc.plugin.texture.TexturePackerPage</a>
						</li>
						
						<li>
							<a href="cc.render.CanvasRenderer.html">cc.render.CanvasRenderer</a>
						</li>
						
						<li>
							<a href="cc.render.DecoratedWebGLRenderingContext.html">cc.render.DecoratedWebGLRenderingContext</a>
						</li>
						
						<li>
							<a href="cc.render.GeometryBatcher.html">cc.render.GeometryBatcher</a>
						</li>
						
						<li>
							<a href="cc.render.Pattern.html">cc.render.Pattern</a>
						</li>
						
						<li>
							<a href="cc.render.Renderer.html">cc.render.Renderer</a>
						</li>
						
						<li>
							<a href="cc.render.RenderingContextSnapshot.html">cc.render.RenderingContextSnapshot</a>
						</li>
						
						<li>
							<a href="cc.render.ScaleManager.html">cc.render.ScaleManager</a>
						</li>
						
						<li>
							<a href="cc.render.shader.AbstractShader.html">cc.render.shader.AbstractShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Attribute.html">cc.render.shader.Attribute</a>
						</li>
						
						<li>
							<a href="cc.render.shader.MatrixUniform.html">cc.render.shader.MatrixUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.SolidColorShader.html">cc.render.shader.SolidColorShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureShader.html">cc.render.shader.TextureShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureUniform.html">cc.render.shader.TextureUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Uniform.html">cc.render.shader.Uniform</a>
						</li>
						
						<li>
							<a href="cc.render.Texture2D.html">cc.render.Texture2D</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLRenderer.html">cc.render.WebGLRenderer</a>
						</li>
						
						<li>
							<a href="cc.transition.Transition.html">cc.transition.Transition</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionFade.html">cc.transition.TransitionFade</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionMove.html">cc.transition.TransitionMove</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInB.html">cc.transition.TransitionSlideInB</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInL.html">cc.transition.TransitionSlideInL</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInR.html">cc.transition.TransitionSlideInR</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInT.html">cc.transition.TransitionSlideInT</a>
						</li>
						
						<li>
							<a href="cc.util.Resource.html">cc.util.Resource</a>
						</li>
						
						<li>
							<a href="cc.widget.Button.html">cc.widget.Button</a>
						</li>
						
						<li>
							<a href="cc.widget.Label.html">cc.widget.Label</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#__extends">__extends</a>
						</li>
						
						<li>
							<a href="global.html#test">test</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: action/SchedulerQueue.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/**
 * License: see license.txt file
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// &lt;reference path="./Action.ts"/>
/// &lt;reference path="../node/Node.ts"/>
var cc;
(function (cc) {
    var action;
    (function (action) {
        var Action = cc.action.Action;
        /**
         * @name SchedulerQueueTaskStatus
         * @memberof cc.action
         * @enum
         * @tsenum
         */
        (function (SchedulerQueueTaskStatus) {
            SchedulerQueueTaskStatus[SchedulerQueueTaskStatus["RUNNING"] = 0] = "RUNNING";
            SchedulerQueueTaskStatus[SchedulerQueueTaskStatus["PAUSED"] = 1] = "PAUSED";
            SchedulerQueueTaskStatus[SchedulerQueueTaskStatus["ENDED"] = 2] = "ENDED";
        })(action.SchedulerQueueTaskStatus || (action.SchedulerQueueTaskStatus = {}));
        var SchedulerQueueTaskStatus = action.SchedulerQueueTaskStatus;
        /**
         * @class cc.action.SchedulerQueueTask
         * @classdesc
         *
         * This object represents a Scheduler task.
         * &lt;p>
         * It holds information for an object and a function on that object, as well as time info such as expected
         * repetitions, delay before time count, and the interval between repetitions.
         * &lt;p>
         * It also holds logic for knowing whether the task should be fired or not.
         * A task is fired by calling a function in the context of a target object ie &lt;code>callback.call(target)&lt;/code>.
         * &lt;p>
         *     A task without target, will only invoke the callback function.
         */
        var SchedulerQueueTask = (function () {
            /**
             * Build a new SchedulerQueueTask instance.
             * @method cc.action.SchedulerQueueTask#constructor
             */
            function SchedulerQueueTask() {
                /**
                 * wait this milliseconds before account time.
                 * @member cc.action.SchedulerQueueTask#_startTime
                 * @type {function}
                 * @private
                 */
                this._startTime = 0.0;
                /**
                 * Custom interval call for a Task
                 * @member cc.action.SchedulerQueueTask#_interval
                 * @type {number}
                 * @private
                 */
                this._interval = 0.0;
                /**
                 * Time to wait before counting time.
                 * @member cc.action.SchedulerQueueTask#_delay
                 * @type {number}
                 * @private
                 */
                this._delay = 0.0;
                /**
                 * Internal task state
                 * @member cc.action.SchedulerQueueTask#_status
                 * @see {cc.action.SchedulerQueueTaskStatus}
                 * @type {cc.action.SchedulerQueueTaskStatus}
                 * @private
                 */
                this._status = null;
                /**
                 * Time when the last task repetition was executed.
                 * @member cc.action.SchedulerQueueTask#_prevCallbackNotificationTime
                 * @type {number}
                 * @private
                 */
                this._prevCallbackNotificationTime = 0.0;
                /**
                 * Previous task tick time.
                 * @member cc.action.SchedulerQueueTask#_prevTime
                 * @type {number}
                 * @private
                 */
                this._prevTime = 0.0;
                /**
                 * Task priority.
                 * Tasks are sorted by this value. First in execution will be negative values.
                 * @member cc.action.SchedulerQueueTask#_priority
                 * @type {number}
                 * @private
                 */
                this._priority = 0;
            }
            /**
             * Execute a task.
             * The execution takes into account whether the task repeats and the interval repetition.
             * @method cc.action.SchedulerQueueTask#step
             * @param currentTime {number} current scheduler time
             * @returns {boolean} whether the task must de deleted.
             */
            SchedulerQueueTask.prototype.step = function (currentTime) {
                // marked as ended or is paused ?, do not execute and delete.
                if (this._status === 2 /* ENDED */ || this._status === 1 /* PAUSED */) {
                    return;
                }
                if (currentTime >= this._startTime) {
                    // if repeats and interval is not 0 (fire every frame)
                    if (this._repeat > 0 &amp;&amp; this._interval !== 0.0) {
                        this.__stepForRepetition(currentTime);
                    }
                    else {
                        // either repeats with 0 interval, or is a single shot task
                        this.__doCallback(currentTime - this._prevCallbackNotificationTime);
                        this._prevCallbackNotificationTime = currentTime;
                        // single shot tasks must be recycled
                        if (!this._repeat) {
                            this.end();
                        }
                    }
                }
            };
            SchedulerQueueTask.prototype.__stepForRepetition = function (currentTime) {
                // identify whether the task has fired in another interval boundary time
                var shotIndex = ((currentTime - this._startTime) / this._interval) | 0;
                var prevshotIndex = ((this._prevTime - this._startTime) / this._interval) | 0;
                if (shotIndex > prevshotIndex &amp;&amp; shotIndex > 0) {
                    //this._prevShotIndex= shotIndex;
                    this.__doCallback(currentTime - this._prevCallbackNotificationTime);
                    this._prevCallbackNotificationTime = currentTime;
                }
                this._prevTime = currentTime;
                // so the task is expired ?
                if (currentTime >= this._startTime + this._interval * this._repeat) {
                    // end the task
                    this.end();
                }
            };
            /**
             * Invoke the callback.
             * If target is specified for the task&lt;br>
             *    the callback is invoked like: callback.call( target, elapsedTime, target )&lt;br>
             * else&lt;br>
             *    the callback is invoked like: callback(elapsedTime, target);
             *
             * @method cc.action.SchedulerQueueTask#__doCallback
             * @param elapsedTime {number} time between two consecutive task fires.
             * @private
             */
            SchedulerQueueTask.prototype.__doCallback = function (elapsedTime) {
                if (null === this._target) {
                    this._callback(elapsedTime, this._target);
                }
                else {
                    this.__doCallCallback(elapsedTime);
                }
            };
            SchedulerQueueTask.prototype.__doCallCallback = function (elapsedTime) {
                this._callback.call(this._target, elapsedTime / cc.action.TIMEUNITS, this._target);
            };
            /**
             * Pause the task. If in this state, the task is not fired.
             * @method cc.action.SchedulerQueueTask#pause
             */
            SchedulerQueueTask.prototype.pause = function () {
                this._status = 1 /* PAUSED */;
            };
            /**
             * Resume the current task.
             * @method cc.action.SchedulerQueueTask#resume
             */
            SchedulerQueueTask.prototype.resume = function () {
                this._status = 0 /* RUNNING */;
            };
            /**
             * End the task. Ending turns the task to be elligible for unscheduling and recycling.
             * @method cc.action.SchedulerQueueTask#end
             */
            SchedulerQueueTask.prototype.end = function () {
                this._status = 2 /* ENDED */;
            };
            /**
             * Whether the task is ended.
             * @method cc.action.SchedulerQueueTask#isEnded
             * @returns {boolean}
             */
            SchedulerQueueTask.prototype.isEnded = function () {
                return this._status === 2 /* ENDED */;
            };
            /**
             * Adjust the task time with the Queue time the task is running in.
             * @method cc.action.SchedulerQueueTask#adjustTime
             * @param time {number}
             */
            SchedulerQueueTask.prototype.adjustTime = function (time) {
                this._startTime = time + (this._delay || 0);
                this._prevCallbackNotificationTime = this._startTime;
            };
            return SchedulerQueueTask;
        })();
        action.SchedulerQueueTask = SchedulerQueueTask;
        /**
         * @class cc.action.SchedulerQueue
         * @extends cc.action.Action
         * @classdesc
         *
         * &lt;p>
         * A scheduler queue manages a collection of Tasks. The tasks are scheduled for single or multi shot execution and
         * are guaranteed to execute at the closest schedule interval time. Internally, a SchedulerQueue is an Action.
         * &lt;p>
         * A task is composed of a target, a function (which is a function the target object has) and some time data.
         * The scheduler will take no action to control whether the supplied function exists for the target object.
         * &lt;p>
         * If a task already exists with the data supplied to the &lt;code>schedule&lt;/code> function the task interval will be
         * updated with the new data supplied.
         * &lt;p>
         * Unscheduled actions are removed in the next tick of execution, but actions that are ended are not executed
         * nonetheless.
         * &lt;p>
         * Tasks scheduled from other task execution, are added and executed in the next tick of execution.
         * &lt;p>
         *     Tasks are kept sorted in ascending priority order. A new task added to the scheduler with a priority
         *     equals to any other task will be added after the existing one.
         *
         * @see {cc.action.Action}
         */
        var SchedulerQueue = (function (_super) {
            __extends(SchedulerQueue, _super);
            /**
             * Build a new SchedulerQueue instance.
             * These objects are managed automatically by scenes and should not need to be built manually.
             * @method cc.action.SchedulerQueue#constructor
             */
            function SchedulerQueue() {
                _super.call(this);
                /**
                 * The collection of scheduled tasks.
                 * @type {Array&lt;cc.action.SchedulerQueueTask>}
                 * @member cc.action.SchedulerQueue#_tasks
                 * @private
                 */
                this._tasks = [];
                this._repeatTimes = Number.MAX_VALUE;
                this._duration = 0;
                this._status = 2 /* RUNNING */;
                this._firstExecution = false;
            }
            /**
             * SchedulerQueue repeats forever by default.
             * @method cc.action.SchedulerAction#setRepeatForever
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.setRepeatForever = function () {
                return this;
            };
            /**
             * SchedulerQueue repeats forever by default.
             * @method cc.action.SchedulerAction#setRepeatTimes
             * @param n {number}
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.setRepeatTimes = function (n) {
                return this;
            };
            /**
             * SchedulerQueue have 0 duration.
             * @method cc.action.SchedulerAction#setDuration
             * @param d {number}
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.setDuration = function (d) {
                return this;
            };
            /**
             * SchedulerQueue can't have time info redefined.
             * @method cc.action.SchedulerAction#timeInfo
             * @param delay {number}
             * @param duration {number}
             * @returns {cc.action.SchedulerQueue}
             */
            SchedulerQueue.prototype.timeInfo = function (delay, duration) {
                return this;
            };
            /**
             * Create a schedulable task.
             *
             * @method cc.action.SchedulerQueue.createSchedulerTask
             *
             * @param target {object} this object will be supplied as context to the callback function.
             * @param callback {cc.action.SchedulerTaskCallback}
             * @param interval {number} interval time to elapse between scheduler calls. Can't be less than 16ms. If the
             *   value is less, it will be fired at every frame anyway.
             * @param repeat {number} multi-shot task. Should this event repeat over time ?
             * @param delay {boolean} schedule the task and wait this time before firing the event.
             */
            SchedulerQueue.createSchedulerTask = function (target, callback, interval, repeat, delay) {
                var task = new SchedulerQueueTask();
                task._target = target;
                task._delay = (delay || 0) * cc.action.TIMEUNITS;
                task._callback = callback;
                task._interval = (interval || 0) * cc.action.TIMEUNITS;
                task._repeat = typeof repeat !== "undefined" ? repeat : Number.MAX_VALUE;
                task._status = 0 /* RUNNING */;
                return task;
            };
            /**
             * Schedule a task.
             * @method cc.action.SchedulerQueue#scheduleTask
             * @param target {Object}
             * @param callback {SchedulerTaskCallback}
             * @param interval {number}
             * @param repeat {number}
             * @param delay {number}
             */
            SchedulerQueue.prototype.scheduleTask = function (target, callback, interval, repeat, delay) {
                var worktask = null;
                var task = null;
                // large form
                if (arguments.length > 1) {
                    worktask = SchedulerQueue.createSchedulerTask(target, callback, interval, repeat, delay);
                }
                else {
                    worktask = target;
                }
                task = this.__findTask(worktask._target, worktask._callback);
                if (null === task) {
                    worktask.adjustTime(this._currentTime);
                    this.insertTask(worktask);
                }
                else {
                    task._interval = worktask._interval;
                    // in case it is paused.
                    task._status = 0 /* RUNNING */;
                }
            };
            /**
             * Insert a task in priority order.
             * It uses binary search to find out the correct position.
             * If already exists a task with the same priority, the new task will be inserted after the existing ones.
             * @param task {cc.node.SchedulerQueueTask}
             */
            SchedulerQueue.prototype.insertTask = function (task) {
                // trivial case: empty queue or task priority >= last task in queue's priority
                if (this._tasks.length === 0 || task._priority >= this._tasks[this._tasks.length - 1]._priority) {
                    this._tasks.push(task);
                    return;
                }
                // binay insert
                var left = 0;
                var right = this._tasks.length - 1;
                while (left !== right) {
                    var middle = (right + left) >> 1;
                    var midtask = this._tasks[middle];
                    if (task._priority > midtask._priority) {
                        left = middle + 1;
                    }
                    else if (task._priority &lt; midtask._priority) {
                        right = middle - 1;
                    }
                    else {
                        left += 1;
                    }
                }
                // insert at left position.
                this._tasks.splice(left, 0, task);
            };
            /**
             * Find whether a task composed of a given object and callback already exists.
             * @method cc.action.SchedulerQueue#__findTask
             *
             * @param target {object}
             * @param method {cc.action.SchedulerTaskCallback}
             * @returns {*}
             * @private
             */
            SchedulerQueue.prototype.__findTask = function (target, method) {
                for (var i = 0; i &lt; this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target &amp;&amp; task._callback === method) {
                        return task;
                    }
                }
                return null;
            };
            /**
             * Pause all tasks for a given target.
             *
             * @method cc.action.SchedulerQueue#pauseTarget
             * @param target {object}
             */
            SchedulerQueue.prototype.pauseTarget = function (target) {
                for (var i = 0; i &lt; this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target) {
                        task.pause();
                    }
                }
            };
            /**
             * Pause a concrete task for a target.
             * @method cc.action.SchedulerQueue#pauseTask
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.pauseTask = function (target, callback) {
                for (var i = 0; i &lt; this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target &amp;&amp; task._callback === callback) {
                        task.pause();
                        return;
                    }
                }
            };
            /**
             * End a task for a target.
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.endTask = function (target, callback) {
                for (var i = 0; i &lt; this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target &amp;&amp; task._callback === callback) {
                        task.end();
                        return;
                    }
                }
            };
            /**
             * Resume a paused task for a target. If it was not paused, nothing happens.
             * @method cc.action.SchedulerQueue#resumeTask
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.resumeTask = function (target, callback) {
                for (var i = 0; i &lt; this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target &amp;&amp; task._callback === callback) {
                        task.resume();
                        return;
                    }
                }
            };
            /**
             * Resume all tasks for a target.
             * @method cc.action.SchedulerQueue#resumeTarget
             * @param target {object}
             */
            SchedulerQueue.prototype.resumeTarget = function (target) {
                for (var i = 0; i &lt; this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target) {
                        task.resume();
                    }
                }
            };
            /**
             * Remove all tasks for a target.
             * @method cc.action.SchedulerQueue#unscheduleAllCallbacks
             * @param target {object}
             */
            SchedulerQueue.prototype.unscheduleAllCallbacks = function (target) {
                for (var i = 0; i &lt; this._tasks.length; i++) {
                    var task = this._tasks[i];
                    if (task._target === target) {
                        task.end();
                    }
                }
            };
            /**
             * Unschedule a concrete task for a target.
             * Unschedule means set it as ended, w/o further execution.
             * @method cc.action.SchedulerQueue#unscheduleCallbackForTarget
             * @param target {object}
             * @param callback {cc.action.SchedulerTaskCallback}
             */
            SchedulerQueue.prototype.unscheduleCallbackForTarget = function (target, callback) {
                //this.pauseTask(target,callback);
                this.endTask(target, callback);
            };
            /**
             * Action update.
             * Traverse the task list and execute events.
             * @method cc.action.SchedulerQueue#update
             * @param normalizedTime {number} normalized action time.
             * @param target {cc.node.Node} node object for which the action executes. For Scheduler queues, no target exists.
             */
            SchedulerQueue.prototype.update = function (normalizedTime, target) {
                // prevent that tasks schedules from a firing scheduled task be checked during this tick.
                var len = this._tasks.length;
                for (var i = 0; i &lt; len; i++) {
                    this._tasks[i].step(this._currentTime);
                }
                for (var i = len - 1; i >= 0; i -= 1) {
                    if (this._tasks[i].isEnded()) {
                        this._tasks.splice(i, 1);
                    }
                }
            };
            return SchedulerQueue;
        })(Action);
        action.SchedulerQueue = SchedulerQueue;
    })(action = cc.action || (cc.action = {}));
})(cc || (cc = {}));
</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					@hyperandroid
					<br />
					
					
		<span class="copyright">
		Chukong inc. 2014
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on 23/Tu/2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
