<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CocosJS Source: render/Renderer.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CocosJS</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#cc">cc</a>
						</li>
						
						<li>
							<a href="global.html#cc#action">cc.action</a>
						</li>
						
						<li>
							<a href="cc.Debug.html">cc.Debug</a>
						</li>
						
						<li>
							<a href="cc.game.html">cc.game</a>
						</li>
						
						<li>
							<a href="cc.input.html">cc.input</a>
						</li>
						
						<li>
							<a href="cc.locale.html">cc.locale</a>
						</li>
						
						<li>
							<a href="cc.math.html">cc.math</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html">cc.math.path</a>
						</li>
						
						<li>
							<a href="cc.node.html">cc.node</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.html">cc.node.sprite</a>
						</li>
						
						<li>
							<a href="cc.plugin.html">cc.plugin</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.html">cc.plugin.asset</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.html">cc.plugin.audio</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.html">cc.plugin.layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.html">cc.plugin.loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.html">cc.plugin.texture</a>
						</li>
						
						<li>
							<a href="cc.render.html">cc.render</a>
						</li>
						
						<li>
							<a href="cc.render.shader.html">cc.render.shader</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLState.html">cc.render.WebGLState</a>
						</li>
						
						<li>
							<a href="cc.transition.html">cc.transition</a>
						</li>
						
						<li>
							<a href="cc.util.html">cc.util</a>
						</li>
						
						<li>
							<a href="cc.widget.html">cc.widget</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cc.action.Action.html">cc.action.Action</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext.html">cc.action.ActionChainContext</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext_constructor.html">cc.action.ActionChainContext#constructor</a>
						</li>
						
						<li>
							<a href="cc.action.ActionInfo.html">cc.action.ActionInfo</a>
						</li>
						
						<li>
							<a href="cc.action.ActionManager.html">cc.action.ActionManager</a>
						</li>
						
						<li>
							<a href="cc.action.AlphaAction.html">cc.action.AlphaAction</a>
						</li>
						
						<li>
							<a href="cc.action.AnimateAction.html">cc.action.AnimateAction</a>
						</li>
						
						<li>
							<a href="cc.action.Interpolator.html">cc.action.Interpolator</a>
						</li>
						
						<li>
							<a href="cc.action.JumpAction.html">cc.action.JumpAction</a>
						</li>
						
						<li>
							<a href="cc.action.MoveAction.html">cc.action.MoveAction</a>
						</li>
						
						<li>
							<a href="cc.action.ParseInterpolator.html">cc.action.ParseInterpolator</a>
						</li>
						
						<li>
							<a href="cc.action.PathAction.html">cc.action.PathAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyAction.html">cc.action.PropertyAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyInfo.html">cc.action.PropertyInfo</a>
						</li>
						
						<li>
							<a href="cc.action.RotateAction.html">cc.action.RotateAction</a>
						</li>
						
						<li>
							<a href="cc.action.ScaleAction.html">cc.action.ScaleAction</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueue.html">cc.action.SchedulerQueue</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueueTask.html">cc.action.SchedulerQueueTask</a>
						</li>
						
						<li>
							<a href="cc.action.SequenceAction.html">cc.action.SequenceAction</a>
						</li>
						
						<li>
							<a href="cc.action.TintAction.html">cc.action.TintAction</a>
						</li>
						
						<li>
							<a href="cc.game.Game.html">cc.game.Game</a>
						</li>
						
						<li>
							<a href="cc.input.InputManager.html">cc.input.InputManager</a>
						</li>
						
						<li>
							<a href="cc.input.InputManagerEvent.html">cc.input.InputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.KeyActionInfo.html">cc.input.KeyActionInfo</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardCursor.html">cc.input.KeyboardCursor</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardInputManager.html">cc.input.KeyboardInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.KeyInfo.html">cc.input.KeyInfo</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManager.html">cc.input.MouseInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManagerEvent.html">cc.input.MouseInputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.PriorityInputNode.html">cc.input.PriorityInputNode</a>
						</li>
						
						<li>
							<a href="cc.input.SceneGraphInputTreeNode.html">cc.input.SceneGraphInputTreeNode</a>
						</li>
						
						<li>
							<a href="cc.math.Color.html">cc.math.Color</a>
						</li>
						
						<li>
							<a href="cc.math.Dimension.html">cc.math.Dimension</a>
						</li>
						
						<li>
							<a href="cc.math.Matrix3.html">cc.math.Matrix3</a>
						</li>
						
						<li>
							<a href="cc.math.Path.html">cc.math.Path</a>
						</li>
						
						<li>
							<a href="cc.math.path.ContainerSegment.html">cc.math.path.ContainerSegment</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentArc.html">cc.math.path.SegmentArc</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentBezier.html">cc.math.path.SegmentBezier</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentCardinalSpline.html">cc.math.path.SegmentCardinalSpline</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html#SegmentLine">cc.math.path.SegmentLine</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentQuadratic.html">cc.math.path.SegmentQuadratic</a>
						</li>
						
						<li>
							<a href="cc.math.path.SubPath.html">cc.math.path.SubPath</a>
						</li>
						
						<li>
							<a href="cc.math.Rectangle.html">cc.math.Rectangle</a>
						</li>
						
						<li>
							<a href="cc.math.Vector.html">cc.math.Vector</a>
						</li>
						
						<li>
							<a href="cc.node.Director.html">cc.node.Director</a>
						</li>
						
						<li>
							<a href="cc.node.FastSprite.html">cc.node.FastSprite</a>
						</li>
						
						<li>
							<a href="cc.node.Node.html">cc.node.Node</a>
						</li>
						
						<li>
							<a href="cc.node.Scene.html">cc.node.Scene</a>
						</li>
						
						<li>
							<a href="cc.node.Sprite_.html">cc.node.Sprite</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.Animation.html">cc.node.sprite.Animation</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.AnimationCache.html">cc.node.sprite.AnimationCache</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.SpriteFrame.html">cc.node.sprite.SpriteFrame</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.AssetManager.html">cc.plugin.asset.AssetManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioEffect.html">cc.plugin.audio.AudioEffect</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioManager.html">cc.plugin.audio.AudioManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.FontMetrics.html">cc.plugin.font.FontMetrics</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFont.html">cc.plugin.font.SpriteFont</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFontChar.html">cc.plugin.font.SpriteFontChar</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.BorderLayout.html">cc.plugin.layout.BorderLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Gap.html">cc.plugin.layout.Gap</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.GridLayout.html">cc.plugin.layout.GridLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Insets.html">cc.plugin.layout.Insets</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.LayerLayout.html">cc.plugin.layout.LayerLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Layout.html">cc.plugin.layout.Layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Unit.html">cc.plugin.layout.Unit</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.Loader.html">cc.plugin.loader.Loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderAudioBuffer.html">cc.plugin.loader.ResourceLoaderAudioBuffer</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderImage.html">cc.plugin.loader.ResourceLoaderImage</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderJSON.html">cc.plugin.loader.ResourceLoaderJSON</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderXML.html">cc.plugin.loader.ResourceLoaderXML</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePacker.html">cc.plugin.texture.TexturePacker</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerNode.html">cc.plugin.texture.TexturePackerNode</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerPage.html">cc.plugin.texture.TexturePackerPage</a>
						</li>
						
						<li>
							<a href="cc.render.CanvasRenderer.html">cc.render.CanvasRenderer</a>
						</li>
						
						<li>
							<a href="cc.render.DecoratedWebGLRenderingContext.html">cc.render.DecoratedWebGLRenderingContext</a>
						</li>
						
						<li>
							<a href="cc.render.GeometryBatcher.html">cc.render.GeometryBatcher</a>
						</li>
						
						<li>
							<a href="cc.render.Pattern.html">cc.render.Pattern</a>
						</li>
						
						<li>
							<a href="cc.render.Renderer.html">cc.render.Renderer</a>
						</li>
						
						<li>
							<a href="cc.render.RenderingContextSnapshot.html">cc.render.RenderingContextSnapshot</a>
						</li>
						
						<li>
							<a href="cc.render.ScaleManager.html">cc.render.ScaleManager</a>
						</li>
						
						<li>
							<a href="cc.render.shader.AbstractShader.html">cc.render.shader.AbstractShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Attribute.html">cc.render.shader.Attribute</a>
						</li>
						
						<li>
							<a href="cc.render.shader.MatrixUniform.html">cc.render.shader.MatrixUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.SolidColorShader.html">cc.render.shader.SolidColorShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureShader.html">cc.render.shader.TextureShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureUniform.html">cc.render.shader.TextureUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Uniform.html">cc.render.shader.Uniform</a>
						</li>
						
						<li>
							<a href="cc.render.Texture2D.html">cc.render.Texture2D</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLRenderer.html">cc.render.WebGLRenderer</a>
						</li>
						
						<li>
							<a href="cc.transition.Transition.html">cc.transition.Transition</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionFade.html">cc.transition.TransitionFade</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionMove.html">cc.transition.TransitionMove</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInB.html">cc.transition.TransitionSlideInB</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInL.html">cc.transition.TransitionSlideInL</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInR.html">cc.transition.TransitionSlideInR</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInT.html">cc.transition.TransitionSlideInT</a>
						</li>
						
						<li>
							<a href="cc.util.Resource.html">cc.util.Resource</a>
						</li>
						
						<li>
							<a href="cc.widget.Button.html">cc.widget.Button</a>
						</li>
						
						<li>
							<a href="cc.widget.Label.html">cc.widget.Label</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#__extends">__extends</a>
						</li>
						
						<li>
							<a href="global.html#test">test</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: render/Renderer.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/**
 * License: see license.txt file.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// &lt;reference path="../math/Dimension.ts"/>
/// &lt;reference path="../math/Color.ts"/>
/// &lt;reference path="../math/Matrix3.ts"/>
/// &lt;reference path="./RenderingContext.ts"/>
/// &lt;reference path="./ScaleManager.ts"/>
/// &lt;reference path="./Texture2D.ts"/>
/// &lt;reference path="./DecoratedWebGLRenderingContext.ts"/>
/// &lt;reference path="../node/Node.ts"/>
/// &lt;reference path="../node/sprite/SpriteFrame.ts"/>
/// &lt;reference path="../plugin/asset/AssetManager.ts"/>
var cc;
(function (cc) {
    var render;
    (function (render) {
        "use strict";
        /**
         * This flag sets renderer's y axis origin to be on top or bottom (y axis increases up or downwards.
         * &lt;p>
         * Bottom is default's open/webgl while top is canvas' default.
         * &lt;li>The default for CocosJS engine is bottom
         * &lt;li>Setting this flag will affect both renderer types.
         * &lt;li>This flag must be set BEFORE creating a renderer object.
         * &lt;p>
         *     Performance considerations.
         * &lt;p>
         *     While changing this flag for a WebGL renderer has no impact in performance, this is not the case for Canvas.
         *     If (as it is by default) bottom is specified for the renderer origin, there's an important performance penalty.
         *     This is mainly due to the fact that for each node, its coordinate system must be inverted, and thus an extra
         *     call to concatenate the current transformation matrix with the inversion matrix must be performed.
         *     In my MBA (core i7 dual core 2Ghz), with 3000 sprites in canvas the difference can be up to 8 fps. &lt;br>
         *     There could be some solutions to avoid this extra transformation call though:
         *     &lt;li>Invert all your images at compile time. Images are already flipped vertically before loading.
         *     &lt;li>Invert all your images at load time. Extra memory, and extra bootstrapping time.
         *     &lt;li>Change the y axis orientation to "top", and avoid the extra call. This will work for both canvas and
         *         webgl rendering.
         * &lt;p>
         *     In either case, right now, the system DOES apply the extra transformation, and the performance penalty is
         *     there.
         * &lt;p>
         *     It is also important to note that the local coordinate system y-axis will for each node be positioned as well
         *     either at the top or the bottom of the node itself.
         *
         * @member cc.render.RENDER_ORIGIN
         * @type {string}
         */
        render.RENDER_ORIGIN = "bottom";
        function autodetectRenderer(w, h, elem) {
            w = w || 800;
            h = h || 600;
            // BORROWED from Mr Doob (mrdoob.com)
            var webgl = (function () {
                var canvas = document.createElement("canvas");
                try {
                    return !!(typeof window.WebGLRenderingContext !== "undefined") &amp;&amp; (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
                }
                catch (e) {
                    return false;
                }
            })();
            if (webgl) {
                return new cc.render.WebGLRenderer(w, h, document.getElementById(elem));
            }
            return new cc.render.CanvasRenderer(w, h, document.getElementById(elem));
        }
        render.autodetectRenderer = autodetectRenderer;
        var Dimension = cc.math.Dimension;
        /**
         * @class cc.render.Renderer
         * @classdesc
         *
         * Interface for any renderer.
         * Must be subclassed to build a canvas or gl renderer.
         *
         */
        var Renderer = (function () {
            /**
             * Create a new Renderer instance.
             * @param w {width} surface pixels width
             * @param h {height} surface pixels height
             * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
             * @member cc.render.Renderer#constructor
             */
            function Renderer(w, h, surface) {
                /**
                 * Surface to render to.
                 * @member cc.render.Renderer#_surface
                 * @type {HTMLCanvasElement}
                 * @private
                 */
                this._surface = null;
                /**
                 * Rendering context to render on the surface.
                 * @member cc.render.Renderer#_renderingContext
                 * @type {cc.render.RenderingContext}
                 * @private
                 */
                this._renderingContext = null;
                this._dimension = new Dimension();
                this._addedToDOM = false;
                this._scaleManager = null;
                this._onContentScaled = null;
                /**
                 * When scale content is enabled, this flag makes the canvas object to take over the whole screen and not
                 * only the area that honors aspect ratio.
                 * @member cc.render.Renderer#_adjustContentToFullScreen
                 * @type {boolean}
                 * @private
                 */
                this._adjustContentToFullScreen = false;
                this._preferredUnits = null;
                this._sceneHint = 16 /* CENTER */;
                this._surface = typeof surface !== "undefined" ? surface : document.createElement("canvas");
                this._surface.width = typeof w !== "undefined" ? w : 800;
                this._surface.height = typeof h !== "undefined" ? h : 600;
                this._preferredUnits = new Dimension();
                this._preferredUnits.set(w, h);
                this._dimension.set(w, h);
                var me = this;
                this._scaleManager = new cc.render.ScaleManager(this).onWindowResized(function (w, h) {
                    var uw = me._scaleManager._units.width;
                    var uh = me._scaleManager._units.height;
                    if (me._adjustContentToFullScreen) {
                        w = window.innerWidth;
                        h = window.innerHeight;
                    }
                    // preferred dimensions
                    me.setScaleContent(uw, uh, w, h);
                });
                this._addedToDOM = surface ? true : false;
            }
            Renderer.prototype.__calcPreferredUnits = function () {
                var d = new cc.math.Dimension();
                var units = this.getScaleManager()._units;
                if (this.getScaleManager()._contentScaled) {
                    var ratio = Math.min(window.innerWidth / units.width, window.innerHeight / units.height);
                    d.width = window.innerWidth / ratio;
                    d.height = window.innerHeight / ratio;
                }
                else {
                    d.width = units.width;
                    d.height = units.height;
                }
                this._preferredUnits.set(d.width, d.height);
                return d;
            };
            Renderer.prototype.adjustContentToFullScreen = function (hint) {
                this._adjustContentToFullScreen = true;
                this._sceneHint = hint;
                return this;
            };
            Renderer.prototype.onContentScaled = function (callback) {
                this._onContentScaled = callback;
                return this;
            };
            Renderer.prototype.isAddedToDOM = function () {
                return this._addedToDOM;
            };
            Renderer.prototype.addToDOM = function () {
                if (!this.isAddedToDOM()) {
                    document.body.appendChild(this._surface);
                    this._addedToDOM = true;
                }
            };
            /**
             * Get the rendering context. @see {cc.render.Renderer#getRenderingContext}
             * @method cc.render.Renderer#getRenderingContext
             * @returns {cc.render.RenderingContext}
             */
            Renderer.prototype.getRenderingContext = function () {
                return this._renderingContext;
            };
            /**
             * Render a node. @see {cc.render.Renderer#render}
             * @method cc.render.Renderer#render
             */
            Renderer.prototype.render = function (node) {
                node.visit(this._renderingContext);
            };
            /**
             * Flush this renderer (push remaining content to the scene).
             * @method cc.render.Renderer#flush
             */
            Renderer.prototype.flush = function () {
                this._renderingContext.flush();
            };
            Renderer.prototype.getContentSize = function () {
                return this._dimension.clone();
            };
            Renderer.prototype.prepareTexture = function (texture) {
            };
            Renderer.prototype.getScaleContentMatrix = function () {
                return this._scaleManager.getScaleContentMatrix();
            };
            /**
             * Return the internal scale management object.
             * This object handles all things relative to Renderer surface scale and on-screen positioning, as well as
             * orientation changes and content scale ratio calculations.
             * @method cc.node.Director#getScaleManager
             * @see cc.game.ScaleManager
             * @returns {cc.render.ScaleManager}
             */
            Renderer.prototype.getScaleManager = function () {
                return this._scaleManager;
            };
            /**
             * Set renderer surface scale strategy.
             * @method cc.node.Director#setScaleStrategy
             * @param ss {cc.render.ScaleManagerStrategy} how renderer surface should me up/down scaled when the window
             *          changes size.
             * @param sp {cc.render.ScalePosition} how to position the renderer surface on the window object.
             */
            Renderer.prototype.setScaleStrategy = function (ss, sp) {
                this._scaleManager.setScale(ss, sp);
            };
            /**
             * Set internal ratio to adjust screen pixels to game units.
             * A game, usually makes the assumption that one game unit maps directly to one screen pixel.
             * When we want to build better looking games which honor devicePixelRation, retina, etc. we need to undo
             * this direct assumption in favor of other better mechanisms.
             * This method undoes this mapping.
             * For example, my game is 8 by 5 meters and want to see it in a 960x640 pixels screen.
             * The difference between this method and &lt;code>setScaleStrategy&lt;/code> is that this one acts in game content,
             * and setScaleStrategy on the renderer generated image.
             * @method cc.node.Director#setScaleContent
             * @see cc.game.ScaleManager
             * @param w {number} game units width
             * @param h {number} game units height
             * @param cw {number=} canvas width
             * @param ch {number=} canvas height
             * @return {number} the scale factor resulting from the map units-pixels.
             */
            Renderer.prototype.setScaleContent = function (w, h, cw, ch) {
                if (typeof cw !== "undefined" &amp;&amp; typeof ch !== "undefined") {
                    // resize canvas size keeping aspect ratio relative to units size.
                    if (cw / ch > w / h) {
                        cw = w * ch / h + 1;
                    }
                    else {
                        ch = cw * h / w + 1;
                    }
                    cw = Math.ceil(cw);
                    ch = Math.ceil(ch);
                    if (this._adjustContentToFullScreen) {
                        cw = window.innerWidth;
                        ch = window.innerHeight;
                    }
                    // resize canvas object
                    this.__resize(cw >> 0, ch >> 0);
                }
                // make calcs for new unit-pixel ratio (w,h)
                this._scaleManager.setScaleContent(w, h);
                // calculate preferred units for the current canvas size
                this.__calcPreferredUnits();
                var ret = this._scaleManager.getUnitsFactor();
                if (this._onContentScaled) {
                    this._onContentScaled(w, h, this._preferredUnits.width, this._preferredUnits.height, cw, ch, this._sceneHint);
                }
                return ret;
            };
            /**
             * When &lt;code>setScaleContent&lt;/code> has been called this method gives the scale factor for the units-pixel
             * mapping ratio.
             * @method cc.node.Director#getUnitsFactor
             * @returns {number}
             */
            Renderer.prototype.getUnitsFactor = function () {
                return this._scaleManager.getUnitsFactor();
            };
            /**
             * Set renderer surface orientation strategy. If set to landscape or portrait, when the window changes size
             * will notify about valid or wrong orientation.
             * Default orientation is set to BOTH.
             * @method cc.node.Director#setOrientationStrategy
             * @param os {cc.render.OrientationStrategy} desired orientation.
             * @param onOk {cc.render.OrientationCallback}
             * @param onError {cc.render.OrientationCallback}
             */
            Renderer.prototype.setOrientationStrategy = function (os, onOk, onError) {
                this._scaleManager.forceOrientation(os, onOk, onError);
            };
            /**
             * Get whether the device has fullScreen capabilities
             * @method cc.node.Director#isFullScreenCapable
             * @returns {boolean}
             */
            Renderer.prototype.isFullScreenCapable = function () {
                return this._scaleManager.isFullScreenCapable();
            };
            /**
             * Is currently the system in full screen ?
             * @method cc.node.Director#isFullScreen
             * @returns {boolean}
             */
            Renderer.prototype.isFullScreen = function () {
                return this._scaleManager.isFullScreen();
            };
            /**
             * Start full screen process. If the system is not full screen capable will silently fail.
             * @method cc.node.Director#startFullScreen
             * @param f {callback=} optional function called when the system enters full screen.
             */
            Renderer.prototype.startFullScreen = function (f) {
                this._scaleManager.startFullScreen(f);
            };
            /**
             * End full screen process. If the system is not full screen capable will silently fail.
             * @method cc.node.Director#endFullScreen
             * @param f {callback=} optional function called when the system enters full screen.
             */
            Renderer.prototype.endFullScreen = function (f) {
                this._scaleManager.endFullScreen(f);
            };
            Renderer.prototype.forceOrientation = function (os, onOk, onError) {
                return this._scaleManager.forceOrientation(os, onOk, onError);
            };
            Renderer.prototype.checkOrientation = function () {
                return this._scaleManager.checkOrientation();
            };
            Renderer.prototype.__resize = function (w, h) {
                this._surface.width = w;
                this._surface.height = h;
                this._dimension.width = w;
                this._dimension.height = h;
            };
            Renderer.prototype.getType = function () {
                return "";
            };
            return Renderer;
        })();
        render.Renderer = Renderer;
        function dc2d(renderer) {
            var canvas = renderer._surface;
            var c2d = canvas.getContext("2d");
            c2d.flush = function () {
                this.setTransform(1, 0, 0, 1, 0, 0);
            };
            Object.defineProperty(c2d, "type", {
                get: function () {
                    return "canvas";
                },
                enumerable: true,
                configurable: true
            });
            c2d.setFillStyleColor = function (color) {
                this.fillStyle = color.getFillStyle();
            };
            c2d.setFillStyleColorArray = function (colorArray) {
                this.fillStyle = new cc.math.Color(colorArray[0], colorArray[1], colorArray[2], colorArray[3]).getFillStyle();
            };
            // BUGBUG canvas can only do fill pattern with whole images.
            c2d.setFillStylePattern = function (pattern) {
                var _pattern = this.createPattern(pattern.texture._image, pattern.type);
                this.fillStyle = _pattern;
            };
            c2d.setTintColor = function (color) {
                // useless for canvas.
            };
            c2d.clear = function () {
                this.setTransform(1, 0, 0, 1, 0, 0);
                this.clearRect(0, 0, this.getWidth(), this.getHeight());
            };
            c2d.getUnitsFactor = function () {
                return renderer.getUnitsFactor();
            };
            c2d.getWidth = function () {
                return this.canvas.width;
            };
            c2d.getHeight = function () {
                return this.canvas.height;
            };
            c2d.setCompositeOperation = function (o) {
                this.globalCompositeOperation = cc.render.CompositeOperationToCanvas[o];
            };
            c2d.getCompositeOperation = function () {
                return cc.render.CanvasToComposite[this.globalCompositeOperation];
            };
            c2d.drawTexture = function (texture, sx, sy, sw, sh, dx, dy, dw, dh) {
                "use strict";
                var h;
                if (arguments.length === 3) {
                    if (cc.render.RENDER_ORIGIN === "bottom") {
                        h = sy + texture._image.height;
                        this.translate(0, h);
                        this.scale(1, -1);
                        this.drawImage(texture._image, sx, 0);
                        this.scale(1, -1);
                        this.translate(0, -h);
                    }
                    else {
                        this.drawImage(texture._image, sx, sy);
                    }
                }
                else if (arguments.length === 5) {
                    if (cc.render.RENDER_ORIGIN === "bottom") {
                        h = sy + sh;
                        this.translate(0, h);
                        this.scale(1, -1);
                        this.drawImage(texture._image, sx, 0, sw, sh);
                        this.scale(1, -1);
                        this.translate(0, -h);
                    }
                    else {
                        this.drawImage(texture._image, sx, sy, sw, sh);
                    }
                }
                else {
                    if (cc.render.RENDER_ORIGIN === "bottom") {
                        h = dy + dh;
                        this.translate(0, h);
                        this.scale(1, -1);
                        this.drawImage(texture._image, sx, sy, sw, sh, dx, 0, dw, dh);
                        this.scale(1, -1);
                        this.translate(0, -h);
                    }
                    else {
                        this.drawImage(texture._image, sx, sy, sw, sh, dx, dy, dw, dh);
                    }
                }
            };
            return c2d;
        }
        /**
         * @class cc.render.CanvasRenderer
         * @classdesc
         *
         * Create a Canvas renderer.
         */
        var CanvasRenderer = (function (_super) {
            __extends(CanvasRenderer, _super);
            /**
             * Create a new CanvasRenderer instance
             * @method cc.render.CanvasRenderer#constructor
             * @param w {width} surface pixels width
             * @param h {height} surface pixels height
             * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
             */
            function CanvasRenderer(w, h, surface) {
                _super.call(this, w, h, surface);
                this._renderingContext = dc2d(this);
                cc.plugin.asset.AssetManager.prepareTextures(this);
            }
            Object.defineProperty(CanvasRenderer.prototype, "renderingContext", {
                /**
                 * Get a renderingContext. Has drawing capabilities.
                 * @method cc.render.CanvasRenderer#get:renderingContext
                 * @returns {RenderingContext}
                 */
                get: function () {
                    return this._renderingContext;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CanvasRenderer.prototype, "canvasContext", {
                /**
                 * Get Canvas context (result from calling &lt;code>canvas.getContext&lt;/code>).
                 * @method cc.render.CanvasRenderer#get:canvasContext
                 * @returns {any}
                 */
                get: function () {
                    return this._renderingContext;
                },
                enumerable: true,
                configurable: true
            });
            CanvasRenderer.prototype.getCanvasContext = function () {
                return this._renderingContext;
            };
            CanvasRenderer.prototype.__resize = function (w, h) {
                _super.prototype.__resize.call(this, w, h);
                this._renderingContext = dc2d(this);
            };
            CanvasRenderer.prototype.getType = function () {
                return "canvas";
            };
            return CanvasRenderer;
        })(Renderer);
        render.CanvasRenderer = CanvasRenderer;
        /**
         * @class cc.render.WebGLRenderer
         * @classdesc
         *
         * Create a WebGL Renderer with drawing capabilities like a canvas object.
         */
        var WebGLRenderer = (function (_super) {
            __extends(WebGLRenderer, _super);
            /**
             * Create a new WebGLRenderer instance.
             * @method cc.render.WebGLRenderer#constructor
             * @param w {width} surface pixels width
             * @param h {height} surface pixels height
             * @param surface {HTMLCanvasElement=} canvas object. @see {cc.render.Renderer#initialize}
             */
            function WebGLRenderer(w, h, surface) {
                _super.call(this, w, h, surface);
                /**
                 * The canvas result of calling &lt;code>canvas.getContext("webgl")&lt;/code>
                 * @member cc.render.WebGLRenderer#_webglState
                 * @type {WebGLRenderingContext}
                 * @private
                 */
                this._webglState = null;
                var drc = new cc.render.DecoratedWebGLRenderingContext(this);
                this._webglState = drc._webglState;
                this._renderingContext = drc;
                cc.plugin.asset.AssetManager.prepareTextures(this);
            }
            WebGLRenderer.prototype.getCanvasContext = function () {
                return this._webglState;
            };
            Object.defineProperty(WebGLRenderer.prototype, "renderingContext", {
                /**
                 * Get a renderingContext. Has drawing capabilities like a &lt;code>CanvasRenderingContext2D&lt;/code>
                 * @method cc.render.WebGLRenderer#get:renderingContext
                 * @returns {RenderingContext}
                 */
                get: function () {
                    return this._renderingContext;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WebGLRenderer.prototype, "canvasContext", {
                /**
                 * Get Canvas context (result from calling &lt;code>canvas.getContext&lt;/code>). Gets a gl context.
                 * @method cc.render.WebGLRenderer#get:canvasContext
                 * @returns {WebGLState}
                 */
                get: function () {
                    return this._webglState;
                },
                enumerable: true,
                configurable: true
            });
            WebGLRenderer.prototype.prepareTexture = function (texture) {
                texture.__setAsGLTexture(this._webglState);
            };
            WebGLRenderer.prototype.__resize = function (w, h) {
                _super.prototype.__resize.call(this, w, h);
                this._renderingContext.resize();
                this._webglState = this._renderingContext._webglState;
            };
            WebGLRenderer.prototype.getType = function () {
                return "webgl";
            };
            return WebGLRenderer;
        })(Renderer);
        render.WebGLRenderer = WebGLRenderer;
        /**
         * @name RendererUtil
         * @memberOf cc.render
         *
         * Various rendering helpers like 9path, etc.
         *
         */
        render.RendererUtil = {
            /**
             * Draw a 9 patch from a SpriteFrame.
             * It assumes that the 9 patch frame size is divisible by 3 horizontal and vertically.
             * @param ctx {cc.render.RenderingContext}
             * @param frameName {string}
             * @param x {number}
             * @param y {number}
             * @param w {number}
             * @param h {number}
             * @param patchData {cc.render.PatchData?}
             */
            draw9Patch: function (ctx, frameName, x, y, w, h, patchData) {
                var sf = cc.plugin.asset.AssetManager.getSpriteFrame(frameName);
                if (null === sf) {
                    return;
                }
                // no patchdata, or destination size just scale the image.
                if (typeof patchData === "undefined") {
                    ctx.drawTexture(sf.getTexture(), 0, 0, sf.getWidth(), sf.getHeight(), x, y, w, h);
                    return;
                }
                patchData.left = patchData.left || 0;
                patchData.top = patchData.top || 0;
                patchData.right = patchData.right || 0;
                patchData.bottom = patchData.bottom || 0;
                var paddingW = patchData.left + patchData.right;
                var paddingH = patchData.bottom + patchData.top;
                var spriteBottomHeight = patchData.bottom;
                var spriteTopHeight = patchData.top;
                var spriteBottomY = sf.getHeight() - spriteBottomHeight;
                var spriteMiddleHeight = sf.getHeight() - paddingH;
                var spriteMiddleWidth = sf.getWidth() - paddingW;
                var spriteLeftWidth = patchData.left;
                var scaleFactor = ctx.getUnitsFactor();
                var topy = cc.render.RENDER_ORIGIN === "top" ? y : y + h - spriteTopHeight / scaleFactor;
                var bottomy = cc.render.RENDER_ORIGIN === "top" ? y + h - spriteBottomHeight / scaleFactor : y;
                var middley = cc.render.RENDER_ORIGIN === "top" ? y + spriteTopHeight / scaleFactor : y + spriteBottomHeight / scaleFactor;
                if (patchData.left) {
                    // top left
                    if (patchData.top) {
                        ctx.drawTexture(sf.getTexture(), 0, 0, spriteLeftWidth, spriteTopHeight, x, topy, spriteLeftWidth / scaleFactor, spriteTopHeight / scaleFactor);
                    }
                    // bottom left
                    if (patchData.bottom) {
                        ctx.drawTexture(sf.getTexture(), 0, spriteBottomY, spriteLeftWidth, spriteBottomHeight, x, bottomy, spriteLeftWidth / scaleFactor, spriteBottomHeight / scaleFactor);
                    }
                    ctx.drawTexture(sf.getTexture(), 0, patchData.top, spriteLeftWidth, spriteMiddleHeight, x, middley, spriteLeftWidth / scaleFactor, h - paddingH / scaleFactor);
                }
                if (patchData.right) {
                    // top left
                    if (patchData.top) {
                        ctx.drawTexture(sf.getTexture(), sf.getWidth() - patchData.right, 0, spriteLeftWidth, spriteTopHeight, x + w - patchData.right / scaleFactor, topy, spriteLeftWidth / scaleFactor, spriteTopHeight / scaleFactor);
                    }
                    // bottom left
                    if (patchData.bottom) {
                        ctx.drawTexture(sf.getTexture(), sf.getWidth() - patchData.right, spriteBottomY, spriteLeftWidth, spriteBottomHeight, x + w - patchData.right / scaleFactor, bottomy, spriteLeftWidth / scaleFactor, spriteBottomHeight / scaleFactor);
                    }
                    ctx.drawTexture(sf.getTexture(), sf.getWidth() - patchData.right, patchData.top, spriteLeftWidth, spriteMiddleHeight, x + w - patchData.right / scaleFactor, middley, spriteLeftWidth / scaleFactor, h - paddingH / scaleFactor);
                }
                // top left
                if (patchData.top) {
                    ctx.drawTexture(sf.getTexture(), patchData.left, 0, spriteMiddleWidth, spriteTopHeight, x + patchData.left / scaleFactor, topy, w - paddingW / scaleFactor, spriteTopHeight / scaleFactor);
                }
                // bottom left
                if (patchData.bottom) {
                    ctx.drawTexture(sf.getTexture(), patchData.left, spriteBottomY, spriteMiddleWidth, spriteBottomHeight, x + patchData.left / scaleFactor, bottomy, w - paddingW / scaleFactor, spriteBottomHeight / scaleFactor);
                }
                ctx.drawTexture(sf.getTexture(), patchData.left, patchData.top, spriteMiddleWidth, spriteMiddleHeight, x + patchData.left / scaleFactor, middley, w - paddingW / scaleFactor, h - paddingH / scaleFactor);
            }
        };
    })(render = cc.render || (cc.render = {}));
})(cc || (cc = {}));
</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					@hyperandroid
					<br />
					
					
		<span class="copyright">
		Chukong inc. 2014
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on 23/Tu/2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
