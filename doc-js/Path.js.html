<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CocosJS Source: math/Path.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CocosJS</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#cc">cc</a>
						</li>
						
						<li>
							<a href="global.html#cc#action">cc.action</a>
						</li>
						
						<li>
							<a href="cc.Debug.html">cc.Debug</a>
						</li>
						
						<li>
							<a href="cc.game.html">cc.game</a>
						</li>
						
						<li>
							<a href="cc.input.html">cc.input</a>
						</li>
						
						<li>
							<a href="cc.locale.html">cc.locale</a>
						</li>
						
						<li>
							<a href="cc.math.html">cc.math</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html">cc.math.path</a>
						</li>
						
						<li>
							<a href="cc.node.html">cc.node</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.html">cc.node.sprite</a>
						</li>
						
						<li>
							<a href="cc.plugin.html">cc.plugin</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.html">cc.plugin.asset</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.html">cc.plugin.audio</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.html">cc.plugin.layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.html">cc.plugin.loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.html">cc.plugin.texture</a>
						</li>
						
						<li>
							<a href="cc.render.html">cc.render</a>
						</li>
						
						<li>
							<a href="cc.render.shader.html">cc.render.shader</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLState.html">cc.render.WebGLState</a>
						</li>
						
						<li>
							<a href="cc.transition.html">cc.transition</a>
						</li>
						
						<li>
							<a href="cc.util.html">cc.util</a>
						</li>
						
						<li>
							<a href="cc.widget.html">cc.widget</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cc.action.Action.html">cc.action.Action</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext.html">cc.action.ActionChainContext</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext_constructor.html">cc.action.ActionChainContext#constructor</a>
						</li>
						
						<li>
							<a href="cc.action.ActionInfo.html">cc.action.ActionInfo</a>
						</li>
						
						<li>
							<a href="cc.action.ActionManager.html">cc.action.ActionManager</a>
						</li>
						
						<li>
							<a href="cc.action.AlphaAction.html">cc.action.AlphaAction</a>
						</li>
						
						<li>
							<a href="cc.action.AnimateAction.html">cc.action.AnimateAction</a>
						</li>
						
						<li>
							<a href="cc.action.Interpolator.html">cc.action.Interpolator</a>
						</li>
						
						<li>
							<a href="cc.action.JumpAction.html">cc.action.JumpAction</a>
						</li>
						
						<li>
							<a href="cc.action.MoveAction.html">cc.action.MoveAction</a>
						</li>
						
						<li>
							<a href="cc.action.ParseInterpolator.html">cc.action.ParseInterpolator</a>
						</li>
						
						<li>
							<a href="cc.action.PathAction.html">cc.action.PathAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyAction.html">cc.action.PropertyAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyInfo.html">cc.action.PropertyInfo</a>
						</li>
						
						<li>
							<a href="cc.action.RotateAction.html">cc.action.RotateAction</a>
						</li>
						
						<li>
							<a href="cc.action.ScaleAction.html">cc.action.ScaleAction</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueue.html">cc.action.SchedulerQueue</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueueTask.html">cc.action.SchedulerQueueTask</a>
						</li>
						
						<li>
							<a href="cc.action.SequenceAction.html">cc.action.SequenceAction</a>
						</li>
						
						<li>
							<a href="cc.action.TintAction.html">cc.action.TintAction</a>
						</li>
						
						<li>
							<a href="cc.game.Game.html">cc.game.Game</a>
						</li>
						
						<li>
							<a href="cc.input.InputManager.html">cc.input.InputManager</a>
						</li>
						
						<li>
							<a href="cc.input.InputManagerEvent.html">cc.input.InputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.KeyActionInfo.html">cc.input.KeyActionInfo</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardCursor.html">cc.input.KeyboardCursor</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardInputManager.html">cc.input.KeyboardInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.KeyInfo.html">cc.input.KeyInfo</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManager.html">cc.input.MouseInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManagerEvent.html">cc.input.MouseInputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.PriorityInputNode.html">cc.input.PriorityInputNode</a>
						</li>
						
						<li>
							<a href="cc.input.SceneGraphInputTreeNode.html">cc.input.SceneGraphInputTreeNode</a>
						</li>
						
						<li>
							<a href="cc.math.Color.html">cc.math.Color</a>
						</li>
						
						<li>
							<a href="cc.math.Dimension.html">cc.math.Dimension</a>
						</li>
						
						<li>
							<a href="cc.math.Matrix3.html">cc.math.Matrix3</a>
						</li>
						
						<li>
							<a href="cc.math.Path.html">cc.math.Path</a>
						</li>
						
						<li>
							<a href="cc.math.path.ContainerSegment.html">cc.math.path.ContainerSegment</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentArc.html">cc.math.path.SegmentArc</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentBezier.html">cc.math.path.SegmentBezier</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentCardinalSpline.html">cc.math.path.SegmentCardinalSpline</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html#SegmentLine">cc.math.path.SegmentLine</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentQuadratic.html">cc.math.path.SegmentQuadratic</a>
						</li>
						
						<li>
							<a href="cc.math.path.SubPath.html">cc.math.path.SubPath</a>
						</li>
						
						<li>
							<a href="cc.math.Rectangle.html">cc.math.Rectangle</a>
						</li>
						
						<li>
							<a href="cc.math.Vector.html">cc.math.Vector</a>
						</li>
						
						<li>
							<a href="cc.node.Director.html">cc.node.Director</a>
						</li>
						
						<li>
							<a href="cc.node.FastSprite.html">cc.node.FastSprite</a>
						</li>
						
						<li>
							<a href="cc.node.Node.html">cc.node.Node</a>
						</li>
						
						<li>
							<a href="cc.node.Scene.html">cc.node.Scene</a>
						</li>
						
						<li>
							<a href="cc.node.Sprite_.html">cc.node.Sprite</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.Animation.html">cc.node.sprite.Animation</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.AnimationCache.html">cc.node.sprite.AnimationCache</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.SpriteFrame.html">cc.node.sprite.SpriteFrame</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.AssetManager.html">cc.plugin.asset.AssetManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioEffect.html">cc.plugin.audio.AudioEffect</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioManager.html">cc.plugin.audio.AudioManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.FontMetrics.html">cc.plugin.font.FontMetrics</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFont.html">cc.plugin.font.SpriteFont</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFontChar.html">cc.plugin.font.SpriteFontChar</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.BorderLayout.html">cc.plugin.layout.BorderLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Gap.html">cc.plugin.layout.Gap</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.GridLayout.html">cc.plugin.layout.GridLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Insets.html">cc.plugin.layout.Insets</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.LayerLayout.html">cc.plugin.layout.LayerLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Layout.html">cc.plugin.layout.Layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Unit.html">cc.plugin.layout.Unit</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.Loader.html">cc.plugin.loader.Loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderAudioBuffer.html">cc.plugin.loader.ResourceLoaderAudioBuffer</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderImage.html">cc.plugin.loader.ResourceLoaderImage</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderJSON.html">cc.plugin.loader.ResourceLoaderJSON</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderXML.html">cc.plugin.loader.ResourceLoaderXML</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePacker.html">cc.plugin.texture.TexturePacker</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerNode.html">cc.plugin.texture.TexturePackerNode</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerPage.html">cc.plugin.texture.TexturePackerPage</a>
						</li>
						
						<li>
							<a href="cc.render.CanvasRenderer.html">cc.render.CanvasRenderer</a>
						</li>
						
						<li>
							<a href="cc.render.DecoratedWebGLRenderingContext.html">cc.render.DecoratedWebGLRenderingContext</a>
						</li>
						
						<li>
							<a href="cc.render.GeometryBatcher.html">cc.render.GeometryBatcher</a>
						</li>
						
						<li>
							<a href="cc.render.Pattern.html">cc.render.Pattern</a>
						</li>
						
						<li>
							<a href="cc.render.Renderer.html">cc.render.Renderer</a>
						</li>
						
						<li>
							<a href="cc.render.RenderingContextSnapshot.html">cc.render.RenderingContextSnapshot</a>
						</li>
						
						<li>
							<a href="cc.render.ScaleManager.html">cc.render.ScaleManager</a>
						</li>
						
						<li>
							<a href="cc.render.shader.AbstractShader.html">cc.render.shader.AbstractShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Attribute.html">cc.render.shader.Attribute</a>
						</li>
						
						<li>
							<a href="cc.render.shader.MatrixUniform.html">cc.render.shader.MatrixUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.SolidColorShader.html">cc.render.shader.SolidColorShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureShader.html">cc.render.shader.TextureShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureUniform.html">cc.render.shader.TextureUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Uniform.html">cc.render.shader.Uniform</a>
						</li>
						
						<li>
							<a href="cc.render.Texture2D.html">cc.render.Texture2D</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLRenderer.html">cc.render.WebGLRenderer</a>
						</li>
						
						<li>
							<a href="cc.transition.Transition.html">cc.transition.Transition</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionFade.html">cc.transition.TransitionFade</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionMove.html">cc.transition.TransitionMove</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInB.html">cc.transition.TransitionSlideInB</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInL.html">cc.transition.TransitionSlideInL</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInR.html">cc.transition.TransitionSlideInR</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInT.html">cc.transition.TransitionSlideInT</a>
						</li>
						
						<li>
							<a href="cc.util.Resource.html">cc.util.Resource</a>
						</li>
						
						<li>
							<a href="cc.widget.Button.html">cc.widget.Button</a>
						</li>
						
						<li>
							<a href="cc.widget.Label.html">cc.widget.Label</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#__extends">__extends</a>
						</li>
						
						<li>
							<a href="global.html#test">test</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: math/Path.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/**
 * License: see license.txt file.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// &lt;reference path="./path/Segment.ts"/>
/// &lt;reference path="./path/ContainerSegment.ts"/>
/// &lt;reference path="./path/SubPath.ts"/>
/// &lt;reference path="./Point.ts"/>
/// &lt;reference path="./Matrix3.ts"/>
/// &lt;reference path="../util/Debug.ts"/>
var cc;
(function (cc) {
    var math;
    (function (math) {
        var SubPath = cc.math.path.SubPath;
        var ContainerSegment = cc.math.path.ContainerSegment;
        var Vector = cc.math.Vector;
        var Matrix3 = cc.math.Matrix3;
        var __v0 = new Vector();
        var __v1 = new Vector();
        var __v2 = new Vector();
        var __v3 = new Vector();
        var __m0 = new Float32Array([1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0]);
        var __m1 = new Float32Array([1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0]);
        /**
         *
         * @class cc.math.Path
         * @extends cc.math.path.ContainerSegment
         * @classdesc
         *
         * This class represents a Path Object.
         * By definition a Path is a collection of Segment objects. These segments are SubPath objects or other Paths.
         * Polimorphically a Path is a Segment itself, so complete paths can be added to another SubPath or Path as a Segment.
         *
         * A path has tracing capabilities. It differentiates from a SubPath in a few aspects:
         *  + a Path may have a cache of the stroke it represents.
         *  + a Path may have a cache of the fill it represents.
         *  + when tracing a Path, the Segments added are transformed by a transformation matrix.
         *  + a path represents an aggregation of Subpaths (contours)
         */
        var Path = (function (_super) {
            __extends(Path, _super);
            /**
             * Build a new Path instance.
             * @method cc.math.Path#constructor
             */
            function Path() {
                _super.call(this);
                /**
                 * Path current sub path to add segments to. Initially, the current sub-path is the path itself.
                 * As new sub-paths are created, _currentSubPath will point to that last sub-path.
                 * @member cc.math.Path#_currentSubPath
                 * @type {null}
                 * @private
                 */
                this._currentSubPath = null;
            }
            /**
             * Get the Path's number of SubPaths.
             * @returns {number}
             */
            Path.prototype.numSubPaths = function () {
                return this._segments.length;
            };
            Path.prototype.__newSubPath = function () {
                var subpath = new SubPath();
                this._segments.push(subpath);
                subpath._parent = this;
                this._currentSubPath = subpath;
            };
            /**
             * Test whether this Path is empty, ie has no sub paths.
             * @returns {boolean}
             */
            Path.prototype.isEmpty = function () {
                return this._segments.length === 0;
            };
            /**
             *
             * Make sure the path has a valid sub-path to trace segments on.
             *
             * If the Path has no current sub-path,
             *   a new sub-path is created and its tracer initialized to 0,0.
             * else
             *   if the current sub-path is closed
             *     a new sub-path is created and its tracer initialized to the current sub-path tracer position
             *   endif
             * endif
             *
             * @param x {number=}
             * @param y {number=}
             * @private
             */
            Path.prototype.__ensureSubPath = function (x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (this.isEmpty()) {
                    this.__newSubPath();
                    this._currentSubPath.moveTo(x, y);
                }
            };
            Path.prototype.__chainSubPathIfCurrentIsClosed = function () {
                if (this._currentSubPath.isClosed()) {
                    var pt = this._currentSubPath._currentPoint;
                    this.__newSubPath();
                    this._currentSubPath.moveTo(pt.x, pt.y);
                }
            };
            /**
             * Get the Path current position for tracing.
             * This point corresponds to the tracing position of the current SubPath.
             * @returns {cc.math.Point}
             */
            Path.prototype.getCurrentTracePosition = function () {
                if (this._currentSubPath === null) {
                    cc.Debug.warn(cc.locale.WARN_TRACER_EMPTY, "getCurrentTracePosition");
                    return { x: 0, y: 0 };
                }
                return this._currentSubPath._currentPoint;
            };
            /**
             * Get the Path starting point.
             * It corresponds to the starting point of the first segment it contains, regardless of its type.
             * If there's no current SubPath, an empty Point (0,0) is returned.
             * @returns {*}
             */
            Path.prototype.getStartingPoint = function () {
                if (this._currentSubPath === null) {
                    cc.Debug.warn(cc.locale.WARN_TRACER_EMPTY, "getStartingPoint");
                    return __v0.set(0, 0);
                }
                return this._currentSubPath.getStartingPoint();
            };
            /**
             * Get the Path ending point.
             * It corresponds to the ending point of the last segment it contains, regardless of its type.
             * If there's no current SubPath, an empty Point (0,0) is returned.
             * @returns {*}
             */
            Path.prototype.getEndingPoint = function () {
                if (this._currentSubPath === null) {
                    cc.Debug.warn(cc.locale.WARN_TRACER_EMPTY, "getEndingPoint");
                    return __v0.set(0, 0);
                }
                return this._segments[this._segments.length - 1].getEndingPoint();
            };
            /**
             * Create a poli-line path from a set of Points.
             * If no points, or an empty array is passed, no Path is built and returns null.
             * @param points {Array&lt;cc.math.Vector>}
             * @returns {cc.math.Path} Newly created path or null if the path can't be created.
             * @static
             */
            Path.createFromPoints = function (points) {
                if (!points || points.length === 0) {
                    return null;
                }
                var closedPath = points[0].equals(points[points.length - 1]);
                var path = new Path();
                path.beginPath();
                path.moveTo(points[0].x, points[0].y);
                for (var i = 1; i &lt; (closedPath ? points.length - 1 : points.length); i++) {
                    path.lineTo(points[i].x, points[i].y);
                }
                if (closedPath) {
                    path.closePath();
                }
                return path;
            };
            /**
             * Clear all sub-path data, and revert to the original path object status.
             * Make sure this path is not another's path segment.
             *
             * @method cc.math.Path#beginPath
             */
            Path.prototype.beginPath = function () {
                this._segments = [];
                this._length = 0;
                this._currentSubPath = null;
                this._dirty = true;
                return this;
            };
            Path.prototype.quadraticTo = function (x1, y1, x2, y2, matrix) {
                __v0.set(x1, y1);
                __v1.set(x2, y2);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                }
                this.__ensureSubPath();
                this._currentSubPath.quadraticTo(__v0.x, __v0.y, __v1.x, __v1.y);
                return this;
            };
            Path.prototype.bezierTo = function (x0, y0, x1, y1, x2, y2, matrix) {
                __v0.set(x0, y0);
                __v1.set(x1, y1);
                __v2.set(x2, y2);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                    Matrix3.transformPoint(matrix, __v2);
                }
                this.__ensureSubPath();
                this._currentSubPath.bezierTo(__v0.x, __v0.y, __v1.x, __v1.y, __v2.x, __v2.y);
                return this;
            };
            Path.prototype.catmullRomTo = function (p0) {
                var rest = [];
                for (var _i = 1; _i &lt; arguments.length; _i++) {
                    rest[_i - 1] = arguments[_i];
                }
                if (typeof p0 === "number ") {
                    // assume a catmullromTo segment call with 6 numbers and an optional matrix
                    if (arguments.length &lt; 6) {
                        // not enough arguments
                        return;
                    }
                    this.__catmullRomTo(p0, rest[0], rest[1], rest[2], rest[3], rest[4], tension, arguments.length > 6 ? rest[5] : null);
                }
                else if (Array.isArray(p0)) {
                    var points = p0;
                    var closed = rest[0];
                    var tension = rest[1];
                    var matrix = arguments.length > 3 ? rest[2] : null;
                    // create a collection of catmullrom segments.
                    // copy array.
                    points = points.slice(0);
                    if (closed) {
                        points.unshift(points[points.length - 1]);
                        points.push(points[1]);
                        points.push(points[2]);
                    }
                    else {
                        points.unshift(points[0]);
                        points.push(points[points.length - 1]);
                    }
                    this.moveTo(points[0].x, points[0].y, matrix);
                    for (var i = 1; i &lt; points.length - 2; i++) {
                        this.__catmullRomTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y, tension, matrix);
                    }
                }
                else {
                    console.log("invalid signature Path.catmullRomTo");
                }
                return this;
            };
            /**
             * Add a catmull rom (cardinal spline
             * @param cp0x {number}
             * @param cp0y {number}
             * @param cp1x {number}
             * @param cp1y {number}
             * @param p1x {number}
             * @param p1y {number}
             * @param matrix {Float32Array}
             */
            Path.prototype.__catmullRomTo = function (cp0x, cp0y, cp1x, cp1y, p1x, p1y, tension, matrix) {
                __v0.set(cp0x, cp0y);
                __v1.set(cp1x, cp1y);
                __v2.set(p1x, p1y);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                    Matrix3.transformPoint(matrix, __v2);
                }
                this.__ensureSubPath();
                this._currentSubPath.catmullRomTo(__v0.x, __v0.y, __v1.x, __v1.y, __v2.x, __v2.y, tension);
            };
            /**
             * Close the current SubPath.
             *
             * @returns {cc.math.Path}
             */
            Path.prototype.closePath = function () {
                this._currentSubPath.closePath();
                this._dirty = true;
                return this;
            };
            /**
             * Move the current path tracer to a position.
             * If the current sub-path is not started,
             *   set this point as the sub-path start point.
             * else
             *   if there are segments,
             *      create a new sub-path
             *   else
             *      set sub-path starting point to the new location
             * endif
             *
             * @method cc.math.Path#moveTo
             * @param x {number}
             * @param y {number}
             * @param matrix {cc.math.Float32Array=}
             */
            Path.prototype.moveTo = function (x, y, matrix) {
                if (matrix) {
                    __v0.set(x, y);
                    Matrix3.transformPoint(matrix, __v0);
                    x = __v0.x;
                    y = __v0.y;
                }
                this.__ensureSubPath(x, y);
                this._currentSubPath.moveTo(x, y);
                return this;
            };
            /**
             * Add a line to the current path.
             * If there's no current SubPath,
             * If the current path is not initialized, in will be initialized from 0,0 and a line added.
             *
             * @method cc.math.Path#lineTo
             * @param x {number}
             * @param y {number}
             * @param matrix {Float32Array=}
             */
            Path.prototype.lineTo = function (x, y, matrix) {
                if (matrix) {
                    __v0.set(x, y);
                    Matrix3.transformPoint(matrix, __v0);
                    x = __v0.x;
                    y = __v0.y;
                }
                this.__ensureSubPath(x, y);
                this.__chainSubPathIfCurrentIsClosed();
                this._currentSubPath.lineTo(x, y);
                this._dirty = true;
                return this;
            };
            /**
             * Create a rect as a new SubPath. The rect has 4 segments which conform the rect.
             * It also created a new SubPath movedTo (x,y).
             * @param x {number}
             * @param y {number}
             * @param w {number}
             * @param h {number}
             * @param matrix {Float32Array=} transformation matrix.
             * @returns {cc.math.Path}
             */
            Path.prototype.rect = function (x, y, w, h, matrix) {
                this.__ensureSubPath();
                // may reuse the current subpath ? (nosegments, and not empty)
                if (this._currentSubPath.numSegments() !== 0) {
                    this.__newSubPath();
                }
                __v0.set(x, y);
                __v1.set(x + w, y);
                __v2.set(x + w, y + h);
                __v3.set(x, y + h);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                    Matrix3.transformPoint(matrix, __v1);
                    Matrix3.transformPoint(matrix, __v2);
                    Matrix3.transformPoint(matrix, __v3);
                }
                this.moveTo(__v0.x, __v0.y);
                this.lineTo(__v1.x, __v1.y);
                this.lineTo(__v2.x, __v2.y);
                this.lineTo(__v3.x, __v3.y);
                this.closePath();
                this.__newSubPath();
                this._currentSubPath.moveTo(__v0.x, __v0.y);
                this._dirty = true;
                return this;
            };
            /**
             * Create an arc segment and add it to the current SubPath.
             * If a SubPath exists, a straight line to (x,y) is added.
             * if the angle difference is > 2PI the angle will be clampled to 2PI. The angle difference will be
             * endAngle - startAngle if anticlockwise is false, and startAngle - endAngle otherwise.
             * In this implementation if the radius is &lt; 0, the radius will be set to 0.
             * If the radius is 0 or the diffangle is 0, no arc is added.
             *
             * @param x {number}
             * @param y {number}
             * @param radius {number}
             * @param startAngle {number}
             * @param endAngle {number}
             * @param anticlockwise {boolean} arc draw direction
             * @param matrix {Float32Array}
             */
            Path.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise, matrix) {
                var addLine = false;
                // transform position (center) based on transformation
                __v0.set(x, y);
                if (matrix) {
                    Matrix3.transformPoint(matrix, __v0);
                }
                x = __v0.x;
                y = __v0.y;
                // ensure a valid subpath to add the segment to exists.
                this.__ensureSubPath(x, y);
                // flag add a straight line from the last trace point to the start of the arc (if apply)
                if (this._currentSubPath.numSegments()) {
                    addLine = true;
                }
                // correct angles. always get the smallest angle on the arc.
                var diffAngle = (endAngle - startAngle);
                if (diffAngle > 2 * Math.PI) {
                    diffAngle = 2 * Math.PI;
                }
                else if (diffAngle &lt; -2 * Math.PI) {
                    diffAngle = -2 * Math.PI;
                }
                // if there's no difference between start and end angles, this will be a single point arc.
                if ((-.0001 &lt; diffAngle &amp;&amp; diffAngle &lt; .0001)) {
                    // bugbug should i add a line if flag addLine says so ?
                    return this;
                }
                this.__chainSubPathIfCurrentIsClosed();
                // calculate radius based on transformation. the new radius is a segment of radius size transformed
                // by the current matrix.
                radius = cc.math.path.getDistanceVector(radius, matrix).length();
                // if radius &lt; something visible, do nothing
                if (radius &lt;= 0.1) {
                    this.__ensureSubPath(x, y);
                    return this;
                }
                // calculate start angle based on current matrix
                if (matrix) {
                    Matrix3.copy(__m0, matrix);
                    Matrix3.setRotate(__m1, startAngle);
                    Matrix3.multiply(__m0, __m1);
                    startAngle = cc.math.path.getDistanceVector(1, matrix).angle();
                }
                this._currentSubPath.arc(x, y, radius, startAngle, startAngle + diffAngle, anticlockwise, addLine);
                this._dirty = true;
                return this;
            };
            Path.prototype.clone = function () {
                var path = new Path();
                for (var i = 0; i &lt; this._segments.length; i++) {
                    path._segments.push(this._segments[i].clone());
                }
                path._currentSubPath = path._segments[path._segments.length - 1];
                path._length = this._length;
                return path;
            };
            Path.prototype.paint = function (ctx) {
                ctx.setTransform(1.0, 0, 0, 1.0, 0, 0);
                for (var i = 0; i &lt; this._segments.length; i++) {
                    this._segments[i].paint(ctx);
                }
            };
            return Path;
        })(ContainerSegment);
        math.Path = Path;
    })(math = cc.math || (cc.math = {}));
})(cc || (cc = {}));
</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					@hyperandroid
					<br />
					
					
		<span class="copyright">
		Chukong inc. 2014
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on 23/Tu/2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
