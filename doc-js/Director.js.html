<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CocosJS Source: node/Director.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CocosJS</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#cc">cc</a>
						</li>
						
						<li>
							<a href="global.html#cc#action">cc.action</a>
						</li>
						
						<li>
							<a href="cc.Debug.html">cc.Debug</a>
						</li>
						
						<li>
							<a href="cc.game.html">cc.game</a>
						</li>
						
						<li>
							<a href="cc.input.html">cc.input</a>
						</li>
						
						<li>
							<a href="cc.locale.html">cc.locale</a>
						</li>
						
						<li>
							<a href="cc.math.html">cc.math</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html">cc.math.path</a>
						</li>
						
						<li>
							<a href="cc.node.html">cc.node</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.html">cc.node.sprite</a>
						</li>
						
						<li>
							<a href="cc.plugin.html">cc.plugin</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.html">cc.plugin.asset</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.html">cc.plugin.audio</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.html">cc.plugin.layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.html">cc.plugin.loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.html">cc.plugin.texture</a>
						</li>
						
						<li>
							<a href="cc.render.html">cc.render</a>
						</li>
						
						<li>
							<a href="cc.render.shader.html">cc.render.shader</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLState.html">cc.render.WebGLState</a>
						</li>
						
						<li>
							<a href="cc.transition.html">cc.transition</a>
						</li>
						
						<li>
							<a href="cc.util.html">cc.util</a>
						</li>
						
						<li>
							<a href="cc.widget.html">cc.widget</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cc.action.Action.html">cc.action.Action</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext.html">cc.action.ActionChainContext</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext_constructor.html">cc.action.ActionChainContext#constructor</a>
						</li>
						
						<li>
							<a href="cc.action.ActionInfo.html">cc.action.ActionInfo</a>
						</li>
						
						<li>
							<a href="cc.action.ActionManager.html">cc.action.ActionManager</a>
						</li>
						
						<li>
							<a href="cc.action.AlphaAction.html">cc.action.AlphaAction</a>
						</li>
						
						<li>
							<a href="cc.action.AnimateAction.html">cc.action.AnimateAction</a>
						</li>
						
						<li>
							<a href="cc.action.Interpolator.html">cc.action.Interpolator</a>
						</li>
						
						<li>
							<a href="cc.action.JumpAction.html">cc.action.JumpAction</a>
						</li>
						
						<li>
							<a href="cc.action.MoveAction.html">cc.action.MoveAction</a>
						</li>
						
						<li>
							<a href="cc.action.ParseInterpolator.html">cc.action.ParseInterpolator</a>
						</li>
						
						<li>
							<a href="cc.action.PathAction.html">cc.action.PathAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyAction.html">cc.action.PropertyAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyInfo.html">cc.action.PropertyInfo</a>
						</li>
						
						<li>
							<a href="cc.action.RotateAction.html">cc.action.RotateAction</a>
						</li>
						
						<li>
							<a href="cc.action.ScaleAction.html">cc.action.ScaleAction</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueue.html">cc.action.SchedulerQueue</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueueTask.html">cc.action.SchedulerQueueTask</a>
						</li>
						
						<li>
							<a href="cc.action.SequenceAction.html">cc.action.SequenceAction</a>
						</li>
						
						<li>
							<a href="cc.action.TintAction.html">cc.action.TintAction</a>
						</li>
						
						<li>
							<a href="cc.game.Game.html">cc.game.Game</a>
						</li>
						
						<li>
							<a href="cc.input.InputManager.html">cc.input.InputManager</a>
						</li>
						
						<li>
							<a href="cc.input.InputManagerEvent.html">cc.input.InputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.KeyActionInfo.html">cc.input.KeyActionInfo</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardCursor.html">cc.input.KeyboardCursor</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardInputManager.html">cc.input.KeyboardInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.KeyInfo.html">cc.input.KeyInfo</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManager.html">cc.input.MouseInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManagerEvent.html">cc.input.MouseInputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.PriorityInputNode.html">cc.input.PriorityInputNode</a>
						</li>
						
						<li>
							<a href="cc.input.SceneGraphInputTreeNode.html">cc.input.SceneGraphInputTreeNode</a>
						</li>
						
						<li>
							<a href="cc.math.Color.html">cc.math.Color</a>
						</li>
						
						<li>
							<a href="cc.math.Dimension.html">cc.math.Dimension</a>
						</li>
						
						<li>
							<a href="cc.math.Matrix3.html">cc.math.Matrix3</a>
						</li>
						
						<li>
							<a href="cc.math.Path.html">cc.math.Path</a>
						</li>
						
						<li>
							<a href="cc.math.path.ContainerSegment.html">cc.math.path.ContainerSegment</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentArc.html">cc.math.path.SegmentArc</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentBezier.html">cc.math.path.SegmentBezier</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentCardinalSpline.html">cc.math.path.SegmentCardinalSpline</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html#SegmentLine">cc.math.path.SegmentLine</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentQuadratic.html">cc.math.path.SegmentQuadratic</a>
						</li>
						
						<li>
							<a href="cc.math.path.SubPath.html">cc.math.path.SubPath</a>
						</li>
						
						<li>
							<a href="cc.math.Rectangle.html">cc.math.Rectangle</a>
						</li>
						
						<li>
							<a href="cc.math.Vector.html">cc.math.Vector</a>
						</li>
						
						<li>
							<a href="cc.node.Director.html">cc.node.Director</a>
						</li>
						
						<li>
							<a href="cc.node.FastSprite.html">cc.node.FastSprite</a>
						</li>
						
						<li>
							<a href="cc.node.Node.html">cc.node.Node</a>
						</li>
						
						<li>
							<a href="cc.node.Scene.html">cc.node.Scene</a>
						</li>
						
						<li>
							<a href="cc.node.Sprite_.html">cc.node.Sprite</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.Animation.html">cc.node.sprite.Animation</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.AnimationCache.html">cc.node.sprite.AnimationCache</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.SpriteFrame.html">cc.node.sprite.SpriteFrame</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.AssetManager.html">cc.plugin.asset.AssetManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioEffect.html">cc.plugin.audio.AudioEffect</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioManager.html">cc.plugin.audio.AudioManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.FontMetrics.html">cc.plugin.font.FontMetrics</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFont.html">cc.plugin.font.SpriteFont</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFontChar.html">cc.plugin.font.SpriteFontChar</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.BorderLayout.html">cc.plugin.layout.BorderLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Gap.html">cc.plugin.layout.Gap</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.GridLayout.html">cc.plugin.layout.GridLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Insets.html">cc.plugin.layout.Insets</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.LayerLayout.html">cc.plugin.layout.LayerLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Layout.html">cc.plugin.layout.Layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Unit.html">cc.plugin.layout.Unit</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.Loader.html">cc.plugin.loader.Loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderAudioBuffer.html">cc.plugin.loader.ResourceLoaderAudioBuffer</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderImage.html">cc.plugin.loader.ResourceLoaderImage</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderJSON.html">cc.plugin.loader.ResourceLoaderJSON</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderXML.html">cc.plugin.loader.ResourceLoaderXML</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePacker.html">cc.plugin.texture.TexturePacker</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerNode.html">cc.plugin.texture.TexturePackerNode</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerPage.html">cc.plugin.texture.TexturePackerPage</a>
						</li>
						
						<li>
							<a href="cc.render.CanvasRenderer.html">cc.render.CanvasRenderer</a>
						</li>
						
						<li>
							<a href="cc.render.DecoratedWebGLRenderingContext.html">cc.render.DecoratedWebGLRenderingContext</a>
						</li>
						
						<li>
							<a href="cc.render.GeometryBatcher.html">cc.render.GeometryBatcher</a>
						</li>
						
						<li>
							<a href="cc.render.Pattern.html">cc.render.Pattern</a>
						</li>
						
						<li>
							<a href="cc.render.Renderer.html">cc.render.Renderer</a>
						</li>
						
						<li>
							<a href="cc.render.RenderingContextSnapshot.html">cc.render.RenderingContextSnapshot</a>
						</li>
						
						<li>
							<a href="cc.render.ScaleManager.html">cc.render.ScaleManager</a>
						</li>
						
						<li>
							<a href="cc.render.shader.AbstractShader.html">cc.render.shader.AbstractShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Attribute.html">cc.render.shader.Attribute</a>
						</li>
						
						<li>
							<a href="cc.render.shader.MatrixUniform.html">cc.render.shader.MatrixUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.SolidColorShader.html">cc.render.shader.SolidColorShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureShader.html">cc.render.shader.TextureShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureUniform.html">cc.render.shader.TextureUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Uniform.html">cc.render.shader.Uniform</a>
						</li>
						
						<li>
							<a href="cc.render.Texture2D.html">cc.render.Texture2D</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLRenderer.html">cc.render.WebGLRenderer</a>
						</li>
						
						<li>
							<a href="cc.transition.Transition.html">cc.transition.Transition</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionFade.html">cc.transition.TransitionFade</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionMove.html">cc.transition.TransitionMove</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInB.html">cc.transition.TransitionSlideInB</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInL.html">cc.transition.TransitionSlideInL</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInR.html">cc.transition.TransitionSlideInR</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInT.html">cc.transition.TransitionSlideInT</a>
						</li>
						
						<li>
							<a href="cc.util.Resource.html">cc.util.Resource</a>
						</li>
						
						<li>
							<a href="cc.widget.Button.html">cc.widget.Button</a>
						</li>
						
						<li>
							<a href="cc.widget.Label.html">cc.widget.Label</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#__extends">__extends</a>
						</li>
						
						<li>
							<a href="global.html#test">test</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: node/Director.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/**
 * License: see license.txt file.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// &lt;reference path="./Node.ts"/>
/// &lt;reference path="./Scene.ts"/>
/// &lt;reference path="../math/Dimension.ts"/>
/// &lt;reference path="../math/Matrix3.ts"/>
/// &lt;reference path="../transition/Transition.ts"/>
/// &lt;reference path="../action/ActionManager.ts"/>
/// &lt;reference path="../action/SchedulerQueue.ts"/>
/// &lt;reference path="../locale/Locale.ts"/>
/// &lt;reference path="../util/Debug.ts"/>
/// &lt;reference path="../render/RenderingContext.ts"/>
/// &lt;reference path="../render/Renderer.ts"/>
/// &lt;reference path="../render/ScaleManager.ts"/>
/// &lt;reference path="../input/InputManager.ts"/>
/// &lt;reference path="../input/MouseInputManager.ts"/>
/// &lt;reference path="../render/ScaleManager.ts"/>
var cc;
(function (cc) {
    var node;
    (function (node) {
        "use strict";
        var Node = cc.node.Node;
        var Scene = cc.node.Scene;
        var Debug = cc.Debug;
        var Locale = cc.locale;
        var ActionManager = cc.action.ActionManager;
        /**
         * Enumeration of Director status.
         *
         * @tsenum cc.node.DirectorStatus
         */
        (function (DirectorStatus) {
            DirectorStatus[DirectorStatus["CREATED"] = 0] = "CREATED";
            DirectorStatus[DirectorStatus["RUNNING"] = 1] = "RUNNING";
            DirectorStatus[DirectorStatus["PAUSED"] = 2] = "PAUSED";
            DirectorStatus[DirectorStatus["STOPPED"] = 3] = "STOPPED";
        })(node.DirectorStatus || (node.DirectorStatus = {}));
        var DirectorStatus = node.DirectorStatus;
        var __window = window;
        /**
         * @class cc.node.Director
         * @extends cc.node.Node
         * @classdesc
         *
         * A Director object is the root node of a game.
         * &lt;li>As the primary component, it is a glue which puts together platform features such as Input routing or Texture
         * and image caching, and Scenes and game logic.
         * &lt;li>Each Director has a renderer, which acts on its own Canvas Object. Since V4, Cocos2D HTML5 allows for multiple
         * &lt;li>Director instances and each one can have a different renderer type.
         *
         * &lt;li>Every Director present in a Document, will share a common Texture and Image cache for better resource management.
         *
         * &lt;li>A Director object runs Scenes. The process of switching scenes is handled using a &lt;code>Transition&lt;/code> object.
         * &lt;li>The preferred way of building scenes is by calling &lt;code>director.createScene() -> Scene&lt;/code>
         *
         * @see{cc.node.Scene}
         * @see{cc.node.Transition}
         *
         */
        var Director = (function (_super) {
            __extends(Director, _super);
            /**
             * Create a new Director instance.
             * @method cc.node.Director#constructor
             */
            function Director() {
                _super.call(this);
                /**
                 * Director status
                 * @member cc.node.Director#_status
                 * @type {number}
                 * @private
                 */
                this._status = 0 /* CREATED */;
                /**
                 * Director's renderer.
                 * @member cc.node.Director#_renderer
                 * @type {cc.render.RenderingContext}
                 * @private
                 */
                this._renderer = null;
                /**
                 * Scenes available in this Director.
                 * @member cc.node.Director#_scenes
                 * @type {Array}
                 * @private
                 */
                this._scenes = [];
                /**
                 * requestAnimationFrame shim id.
                 * @member cc.node.Director#_animFrame
                 * @type {number}
                 * @private
                 */
                this._animFrame = null;
                /**
                 * Ideal milliseconds between two frames.
                 * @member cc.node.Director#_animationInterval
                 * @type {number}
                 * @private
                 */
                this._animationInterval = 1000 / 60;
                /**
                 * Currently running Scene.
                 * @member cc.node.Director#_currentScene
                 * @type {cc.node.Scene}
                 * @private
                 */
                this._currentScene = null;
                /**
                 * If &lt;code>runAction&lt;/code> is called with a Transition, _exitingScene will be the currently moving out scene.
                 * For internal usage only.
                 * @member cc.node.Director#_exitingScene
                 * @type {cc.node.Scene}
                 * @private
                 */
                this._exitingScene = null;
                /**
                 * Scenes action manager that manages Transition objects.
                 * @member cc.node.Director#_scenesActionManager
                 * @type {cc.action.ActionManager}
                 * @private
                 * @see {cc.transition.Transition}
                 */
                this._scenesActionManager = null;
                /**
                 * Timer management. This value is the previous time the director run at.
                 * @member cc.node.Director#_prevPerf
                 * @type {number}
                 * @private
                 */
                this._prevPerf = 0;
                /**
                 * General input management system
                 * @member cc.node.Director#_inputManager
                 * @type {cc.input.InputManager}
                 * @private
                 */
                this._inputManager = null;
                this._scheduler = null;
                this._scenesActionManager = new ActionManager();
                this._scheduler = this._scenesActionManager.getScheduler();
                this._inputManager = new cc.input.InputManager();
                // BUGBUG deprecated
                cc.director = this;
            }
            /**
             * Get the current renderer.
             * @method cc.node.Director#getRenderer
             * @returns {Renderer}
             */
            Director.prototype.getRenderer = function () {
                return this._renderer;
            };
            /**
             * Set the Director's renderer.
             * It will also enable input on the renderer surface.
             * @method cc.node.Director#setRenderingContext
             * @param renderer {cc.render.Renderer}
             * @returns {cc.node.Director}
             */
            Director.prototype.setRenderer = function (renderer) {
                this._renderer = renderer;
                this._contentSize.set(renderer.getContentSize());
                this._modelViewMatrix = this._renderer.getScaleContentMatrix();
                this._worldModelViewMatrix = this._renderer.getScaleContentMatrix();
                this._inputManager.enable(renderer._surface);
                var me = this;
                renderer.onContentScaled(function (unitsWidth, unitsHeight, preferredUnitsWidth, preferredUnitsHeight, canvasWidth, canvasHeight, sceneHint) {
                    me.setContentSize(canvasWidth, canvasHeight);
                    if (sceneHint &amp; 16 /* CENTER */) {
                        me._currentScene.setContentSize(unitsWidth, unitsHeight);
                        me._currentScene.setPosition((preferredUnitsWidth - unitsWidth) / 2, (preferredUnitsHeight - unitsHeight) / 2);
                    }
                    else if (sceneHint &amp; 32 /* STRETCH */) {
                        me._currentScene.setContentSize(preferredUnitsWidth, preferredUnitsHeight);
                        me._currentScene.setPosition(0, 0);
                    }
                    else {
                        var x = 0;
                        var y = 0;
                        if (sceneHint &amp; 8 /* RIGHT */) {
                            x = preferredUnitsWidth - unitsWidth;
                        }
                        if ((cc.render.RENDER_ORIGIN === "top" &amp;&amp; sceneHint &amp; 4 /* BOTTOM */) || (cc.render.RENDER_ORIGIN === "bottom" &amp;&amp; sceneHint &amp; 1 /* TOP */)) {
                            y = preferredUnitsHeight - unitsHeight;
                        }
                        me._currentScene.setContentSize(unitsWidth, unitsHeight);
                        me._currentScene.setPosition(x, y);
                    }
                });
                return this;
            };
            Director.prototype.__setTransform = function () {
                return this;
            };
            Director.prototype.__setLocalTransform = function () {
            };
            Director.prototype.__setWorldTransform = function () {
            };
            /**
             * Get the system input manager object.
             * @method cc.node.Director#getInputManager
             * @returns {cc.input.InputManager}
             */
            Director.prototype.getInputManager = function () {
                return this._inputManager;
            };
            /**
             * Pause the Director.
             * The animation loop is stopped.
             * @method cc.node.Director#pause
             */
            Director.prototype.pause = function () {
                if (this._status === 2 /* PAUSED */) {
                    return;
                }
                this.stopAnimation();
                this._status = 2 /* PAUSED */;
            };
            /**
             * Resume a paused director.
             * The animation loop restarts.
             * @method cc.node.Director#resume
             */
            Director.prototype.resume = function () {
                if (this._status !== 2 /* PAUSED */) {
                    return;
                }
                this.startAnimation();
            };
            /**
             * Make the renderer visible in the document.
             * @method cc.node.Director#addToDOM
             */
            Director.prototype.addToDOM = function () {
                this._renderer.addToDOM();
            };
            Director.prototype.__sceneExitedDirector = function (scene) {
                if (scene) {
                    scene.callOnExit();
                    scene.cleanup();
                    scene._parent = null;
                }
            };
            /**
             * Run a Scene.
             * Optionally use a transition for switching between scenes.
             * @method cc.node.Director#runScene
             * @param scene {cc.node.Scene}
             * @param transition {cc.transition.Transition}
             */
            Director.prototype.runScene = function (scene_or_transition, transition) {
                var _this = this;
                var scene;
                if (scene_or_transition instanceof Scene) {
                    scene = scene_or_transition;
                }
                else if (scene_or_transition instanceof cc.transition.Transition) {
                    // v3 style call
                    transition = scene_or_transition;
                    scene = transition._sceneIn;
                    if (!scene) {
                        throw "director.runAction(transition) has no scene set.";
                    }
                }
                else {
                    throw "Director.runScene with wrong object type.";
                }
                // wtf. zero sized containers should have no content.
                // the scene-graph will discard them immediately. This code here for backwards compatibility only.
                if (scene.width === 0 || scene.height === 0) {
                    var pw = this.getRenderer()._preferredUnits;
                    scene.setContentSize(pw.width, pw.height);
                }
                scene._parent = this;
                // the renderer will check whether it is already added.
                this.addToDOM();
                // if there's a transition, let the transition handle onExit.
                if (typeof transition !== "undefined") {
                    this._exitingScene = this._currentScene;
                    transition.initialize(scene, this._currentScene).onDirectorTransitionEnd(function (tr) {
                        //if ( this._exitingScene ) {
                        //    this.__sceneExitedDirector(this._exitingScene);
                        //}
                        _this._exitingScene = null;
                    });
                }
                else {
                    // if not, and there's a current scene
                    if (this._currentScene) {
                        // call onExit.
                        this.__sceneExitedDirector(this._currentScene);
                    }
                    // scene entered w/o transition.
                    scene.callOnEnter();
                }
                this._currentScene = scene;
                cc.input.MouseInputManager.enableInputForScene(scene);
                // check for valid orientation.
                this._renderer.checkOrientation();
                if (this._status !== 1 /* RUNNING */) {
                    this.startAnimation();
                }
            };
            /**
             * Push a new running scene on top of the stack.
             * @method cc.node.Director#pushScene
             * @param scene {cc.node.Scene}
             */
            Director.prototype.pushScene = function (scene) {
                if (this._scenes.indexOf(scene) !== -1) {
                    Debug.error(Locale.ERR_RUNNING_ALREADY_EXISTING_SCENE);
                    return;
                }
                this._scenes.push(scene);
                this.runScene(scene);
            };
            /**
             * Pop a scene from the running stack.
             * @method cc.node.Director#popScene
             * @throws cc.locale.Locale.ERR_DIRECTOR_POPSCENE_UDERFLOW if DEBUG_LEVEL is RuntimeDebugLevel.DEBUG.
             */
            Director.prototype.popScene = function () {
                if (this._scenes.length === 0) {
                    Debug.error(Locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW);
                    return;
                }
                var exitScene = this._scenes.pop();
                this.__sceneExitedDirector(exitScene);
                if (this._scenes.length > 0) {
                    this._currentScene = this._scenes[this._scenes.length - 1];
                    this._currentScene.callOnEnter();
                }
                else {
                }
            };
            /**
             * Pop all scenes but one.
             * @method cc.node.Director#popToRootScene
             */
            Director.prototype.popToRootScene = function () {
                this.popToSceneStackLevel(1);
            };
            /**
             * Remove scenes from the stack until reaching 'level' scenes stack length.
             * @method cc.node.Director#popToSceneStackLevel
             * @param level {number}
             */
            Director.prototype.popToSceneStackLevel = function (level) {
                level = this._scenes.length - level;
                if (level &lt;= 0) {
                    Debug.error(Locale.ERR_DIRECTOR_POPSCENE_UNDERFLOW);
                    return;
                }
                while (level) {
                    this.popScene();
                    level--;
                }
            };
            /**
             * Start Director's animation loop.
             * Don't call directly, or only call after manually calling &lt;code>stopAnimation&lt;/code>
             * @method cc.node.Director#startAnimation
             */
            Director.prototype.startAnimation = function () {
                if (this._status === 1 /* RUNNING */) {
                    Debug.warn(Locale.WARN_START_ANIMATION_ON_RUNNING_DIRECTOR);
                    return;
                }
                this._status = 1 /* RUNNING */;
                var fn = this.mainLoop.bind(this);
                var me = this;
                function raf(perf) {
                    fn(perf);
                    me._animFrame = __window.requestAnimFrame(raf);
                }
                this._animFrame = __window.requestAnimFrame(raf);
                if (this._currentScene) {
                    cc.input.MouseInputManager.enableInputForScene(this._currentScene);
                }
            };
            /**
             * Stop Director's animation loop.
             * The Director status will be STOPPED.
             * @method cc.node.Director#stopAnimation
             */
            Director.prototype.stopAnimation = function () {
                if (this._status !== 1 /* RUNNING */) {
                    return;
                }
                this._status = 3 /* STOPPED */;
                if (this._animFrame !== null) {
                    __window.cancelAnimationFrame(this._animFrame);
                    this._animFrame = null;
                }
                if (this._currentScene) {
                    cc.input.MouseInputManager.disableInputForScene();
                }
            };
            /**
             * Throttle animation loop.
             * This value will be the minimum millis to wait between two frames.
             * Currently does nothing.
             * @method cc.node.Director#setAnimationInterval
             * @param interval {number}
             */
            Director.prototype.setAnimationInterval = function (interval) {
                this._animationInterval = interval;
            };
            /**
             * Main director animation Loop.
             * Don't call directly this method. It is called by startAnimation when the first scene is scheduled in the
             * Director object.
             *
             * PENDING: throttle FPS with _animationInterval value.
             *
             * @method cc.node.Director#mainLoop
             * @param perf {number=} performance time elapsed between two RAF calls.
             */
            Director.prototype.mainLoop = function (perf) {
                if (this._status !== 1 /* RUNNING */) {
                    return;
                }
                var deltaTime;
                if (typeof perf === "undefined") {
                    perf = new Date().getTime();
                }
                deltaTime = perf - this._prevPerf;
                // prevent feeding huge time increments. Useful for debugging.
                if (deltaTime > 250) {
                    deltaTime = 250;
                }
                this._prevPerf = perf;
                var ctx = this._renderer.getRenderingContext();
                ctx.clear();
                // do director's paint as a node.
                // A director does not have any action associated, so just paint.
                this.visit(ctx);
                // Step time for active scenes.
                // At any given moment, as much as two scenes can be active.
                // If a transition is in place, two scenes will be active.
                // If not, only one scene is active.
                this._scenesActionManager.step(deltaTime / cc.action.TIMEUNITS);
                // do current scene's visit when
                // transitions end.
                if (this._exitingScene) {
                    this._exitingScene.step(deltaTime / cc.action.TIMEUNITS, ctx);
                }
                this._currentScene.step(deltaTime / cc.action.TIMEUNITS, ctx);
                if (this._renderer.flush) {
                    this._renderer.flush();
                }
            };
            /**
             * Create an scene object.
             * The created Scene will have the size of this director object and have a reference to the director.
             * @method cc.node.Director#createScene
             * @returns {cc.node.Scene}
             */
            Director.prototype.createScene = function () {
                var scene = new Scene();
                scene.setContentSize(this._contentSize.width, this._contentSize.height);
                return scene;
            };
            /**
             * Get director size as a dimension object.
             * The object is a copy of the internal contentSize variable.
             * This method is for backwards compatibility
             * @method cc.node.Director#getWinSize
             * @returns {cc.math.Dimension}
             */
            Director.prototype.getWinSize = function () {
                return this._contentSize.clone();
            };
            Director.prototype.scheduleTask = function (task) {
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a task for the node.
             * This node will be passed as target to the specified callback function.
             * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
             * with the new data.
             * @method cc.node.Node#schedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
             * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
             * @param repeat {number=} number of repetitions. if not set, infinite will be used.
             * @param delay {number=} wait this millis before firing the task.
             */
            Director.prototype.schedule = function (callback_fn, interval, repeat, delay) {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, callback_fn, interval, repeat, delay);
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a single shot task. Will fired only once.
             * @method cc.node.Node#scheduleOnce
             * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
             * @param delay {number} milliseconds to wait before firing the task.
             * @returns {cc.node.Node}
             */
            Director.prototype.scheduleOnce = function (callback_fn, delay) {
                this.schedule(callback_fn, 0.0, 0, delay);
            };
            /**
             * Unschedule a task for the node.
             * @method cc.node.Node#unschedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
             */
            Director.prototype.unschedule = function (callback_fn) {
                if (!callback_fn)
                    return;
                this._scheduler.unscheduleCallbackForTarget(this, callback_fn);
            };
            /**
             * Unschedule all tasks for the node.
             * @method cc.node.Node#unscheduleAllCallbacks
             */
            Director.prototype.unscheduleAllCallbacks = function (target) {
                this._scheduler.unscheduleAllCallbacks(target ? target : this);
            };
            return Director;
        })(Node);
        node.Director = Director;
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					@hyperandroid
					<br />
					
					
		<span class="copyright">
		Chukong inc. 2014
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on 23/Tu/2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
