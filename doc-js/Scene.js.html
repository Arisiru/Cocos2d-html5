<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CocosJS Source: node/Scene.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">CocosJS</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#cc">cc</a>
						</li>
						
						<li>
							<a href="global.html#cc#action">cc.action</a>
						</li>
						
						<li>
							<a href="cc.Debug.html">cc.Debug</a>
						</li>
						
						<li>
							<a href="cc.game.html">cc.game</a>
						</li>
						
						<li>
							<a href="cc.input.html">cc.input</a>
						</li>
						
						<li>
							<a href="cc.locale.html">cc.locale</a>
						</li>
						
						<li>
							<a href="cc.math.html">cc.math</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html">cc.math.path</a>
						</li>
						
						<li>
							<a href="cc.node.html">cc.node</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.html">cc.node.sprite</a>
						</li>
						
						<li>
							<a href="cc.plugin.html">cc.plugin</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.html">cc.plugin.asset</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.html">cc.plugin.audio</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.html">cc.plugin.layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.html">cc.plugin.loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.html">cc.plugin.texture</a>
						</li>
						
						<li>
							<a href="cc.render.html">cc.render</a>
						</li>
						
						<li>
							<a href="cc.render.shader.html">cc.render.shader</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLState.html">cc.render.WebGLState</a>
						</li>
						
						<li>
							<a href="cc.transition.html">cc.transition</a>
						</li>
						
						<li>
							<a href="cc.util.html">cc.util</a>
						</li>
						
						<li>
							<a href="cc.widget.html">cc.widget</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="cc.action.Action.html">cc.action.Action</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext.html">cc.action.ActionChainContext</a>
						</li>
						
						<li>
							<a href="cc.action.ActionChainContext_constructor.html">cc.action.ActionChainContext#constructor</a>
						</li>
						
						<li>
							<a href="cc.action.ActionInfo.html">cc.action.ActionInfo</a>
						</li>
						
						<li>
							<a href="cc.action.ActionManager.html">cc.action.ActionManager</a>
						</li>
						
						<li>
							<a href="cc.action.AlphaAction.html">cc.action.AlphaAction</a>
						</li>
						
						<li>
							<a href="cc.action.AnimateAction.html">cc.action.AnimateAction</a>
						</li>
						
						<li>
							<a href="cc.action.Interpolator.html">cc.action.Interpolator</a>
						</li>
						
						<li>
							<a href="cc.action.JumpAction.html">cc.action.JumpAction</a>
						</li>
						
						<li>
							<a href="cc.action.MoveAction.html">cc.action.MoveAction</a>
						</li>
						
						<li>
							<a href="cc.action.ParseInterpolator.html">cc.action.ParseInterpolator</a>
						</li>
						
						<li>
							<a href="cc.action.PathAction.html">cc.action.PathAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyAction.html">cc.action.PropertyAction</a>
						</li>
						
						<li>
							<a href="cc.action.PropertyInfo.html">cc.action.PropertyInfo</a>
						</li>
						
						<li>
							<a href="cc.action.RotateAction.html">cc.action.RotateAction</a>
						</li>
						
						<li>
							<a href="cc.action.ScaleAction.html">cc.action.ScaleAction</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueue.html">cc.action.SchedulerQueue</a>
						</li>
						
						<li>
							<a href="cc.action.SchedulerQueueTask.html">cc.action.SchedulerQueueTask</a>
						</li>
						
						<li>
							<a href="cc.action.SequenceAction.html">cc.action.SequenceAction</a>
						</li>
						
						<li>
							<a href="cc.action.TintAction.html">cc.action.TintAction</a>
						</li>
						
						<li>
							<a href="cc.game.Game.html">cc.game.Game</a>
						</li>
						
						<li>
							<a href="cc.input.InputManager.html">cc.input.InputManager</a>
						</li>
						
						<li>
							<a href="cc.input.InputManagerEvent.html">cc.input.InputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.KeyActionInfo.html">cc.input.KeyActionInfo</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardCursor.html">cc.input.KeyboardCursor</a>
						</li>
						
						<li>
							<a href="cc.input.KeyboardInputManager.html">cc.input.KeyboardInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.KeyInfo.html">cc.input.KeyInfo</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManager.html">cc.input.MouseInputManager</a>
						</li>
						
						<li>
							<a href="cc.input.MouseInputManagerEvent.html">cc.input.MouseInputManagerEvent</a>
						</li>
						
						<li>
							<a href="cc.input.PriorityInputNode.html">cc.input.PriorityInputNode</a>
						</li>
						
						<li>
							<a href="cc.input.SceneGraphInputTreeNode.html">cc.input.SceneGraphInputTreeNode</a>
						</li>
						
						<li>
							<a href="cc.math.Color.html">cc.math.Color</a>
						</li>
						
						<li>
							<a href="cc.math.Dimension.html">cc.math.Dimension</a>
						</li>
						
						<li>
							<a href="cc.math.Matrix3.html">cc.math.Matrix3</a>
						</li>
						
						<li>
							<a href="cc.math.Path.html">cc.math.Path</a>
						</li>
						
						<li>
							<a href="cc.math.path.ContainerSegment.html">cc.math.path.ContainerSegment</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentArc.html">cc.math.path.SegmentArc</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentBezier.html">cc.math.path.SegmentBezier</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentCardinalSpline.html">cc.math.path.SegmentCardinalSpline</a>
						</li>
						
						<li>
							<a href="cc.math.path_.html#SegmentLine">cc.math.path.SegmentLine</a>
						</li>
						
						<li>
							<a href="cc.math.path.SegmentQuadratic.html">cc.math.path.SegmentQuadratic</a>
						</li>
						
						<li>
							<a href="cc.math.path.SubPath.html">cc.math.path.SubPath</a>
						</li>
						
						<li>
							<a href="cc.math.Rectangle.html">cc.math.Rectangle</a>
						</li>
						
						<li>
							<a href="cc.math.Vector.html">cc.math.Vector</a>
						</li>
						
						<li>
							<a href="cc.node.Director.html">cc.node.Director</a>
						</li>
						
						<li>
							<a href="cc.node.FastSprite.html">cc.node.FastSprite</a>
						</li>
						
						<li>
							<a href="cc.node.Node.html">cc.node.Node</a>
						</li>
						
						<li>
							<a href="cc.node.Scene.html">cc.node.Scene</a>
						</li>
						
						<li>
							<a href="cc.node.Sprite_.html">cc.node.Sprite</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.Animation.html">cc.node.sprite.Animation</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.AnimationCache.html">cc.node.sprite.AnimationCache</a>
						</li>
						
						<li>
							<a href="cc.node.sprite.SpriteFrame.html">cc.node.sprite.SpriteFrame</a>
						</li>
						
						<li>
							<a href="cc.plugin.asset.AssetManager.html">cc.plugin.asset.AssetManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioEffect.html">cc.plugin.audio.AudioEffect</a>
						</li>
						
						<li>
							<a href="cc.plugin.audio.AudioManager.html">cc.plugin.audio.AudioManager</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.FontMetrics.html">cc.plugin.font.FontMetrics</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFont.html">cc.plugin.font.SpriteFont</a>
						</li>
						
						<li>
							<a href="cc.plugin.font.SpriteFontChar.html">cc.plugin.font.SpriteFontChar</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.BorderLayout.html">cc.plugin.layout.BorderLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Gap.html">cc.plugin.layout.Gap</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.GridLayout.html">cc.plugin.layout.GridLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Insets.html">cc.plugin.layout.Insets</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.LayerLayout.html">cc.plugin.layout.LayerLayout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Layout.html">cc.plugin.layout.Layout</a>
						</li>
						
						<li>
							<a href="cc.plugin.layout.Unit.html">cc.plugin.layout.Unit</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.Loader.html">cc.plugin.loader.Loader</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderAudioBuffer.html">cc.plugin.loader.ResourceLoaderAudioBuffer</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderImage.html">cc.plugin.loader.ResourceLoaderImage</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderJSON.html">cc.plugin.loader.ResourceLoaderJSON</a>
						</li>
						
						<li>
							<a href="cc.plugin.loader.ResourceLoaderXML.html">cc.plugin.loader.ResourceLoaderXML</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePacker.html">cc.plugin.texture.TexturePacker</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerNode.html">cc.plugin.texture.TexturePackerNode</a>
						</li>
						
						<li>
							<a href="cc.plugin.texture.TexturePackerPage.html">cc.plugin.texture.TexturePackerPage</a>
						</li>
						
						<li>
							<a href="cc.render.CanvasRenderer.html">cc.render.CanvasRenderer</a>
						</li>
						
						<li>
							<a href="cc.render.DecoratedWebGLRenderingContext.html">cc.render.DecoratedWebGLRenderingContext</a>
						</li>
						
						<li>
							<a href="cc.render.GeometryBatcher.html">cc.render.GeometryBatcher</a>
						</li>
						
						<li>
							<a href="cc.render.Pattern.html">cc.render.Pattern</a>
						</li>
						
						<li>
							<a href="cc.render.Renderer.html">cc.render.Renderer</a>
						</li>
						
						<li>
							<a href="cc.render.RenderingContextSnapshot.html">cc.render.RenderingContextSnapshot</a>
						</li>
						
						<li>
							<a href="cc.render.ScaleManager.html">cc.render.ScaleManager</a>
						</li>
						
						<li>
							<a href="cc.render.shader.AbstractShader.html">cc.render.shader.AbstractShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Attribute.html">cc.render.shader.Attribute</a>
						</li>
						
						<li>
							<a href="cc.render.shader.MatrixUniform.html">cc.render.shader.MatrixUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.SolidColorShader.html">cc.render.shader.SolidColorShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureShader.html">cc.render.shader.TextureShader</a>
						</li>
						
						<li>
							<a href="cc.render.shader.TextureUniform.html">cc.render.shader.TextureUniform</a>
						</li>
						
						<li>
							<a href="cc.render.shader.Uniform.html">cc.render.shader.Uniform</a>
						</li>
						
						<li>
							<a href="cc.render.Texture2D.html">cc.render.Texture2D</a>
						</li>
						
						<li>
							<a href="cc.render.WebGLRenderer.html">cc.render.WebGLRenderer</a>
						</li>
						
						<li>
							<a href="cc.transition.Transition.html">cc.transition.Transition</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionFade.html">cc.transition.TransitionFade</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionMove.html">cc.transition.TransitionMove</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInB.html">cc.transition.TransitionSlideInB</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInL.html">cc.transition.TransitionSlideInL</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInR.html">cc.transition.TransitionSlideInR</a>
						</li>
						
						<li>
							<a href="cc.transition.TransitionSlideInT.html">cc.transition.TransitionSlideInT</a>
						</li>
						
						<li>
							<a href="cc.util.Resource.html">cc.util.Resource</a>
						</li>
						
						<li>
							<a href="cc.widget.Button.html">cc.widget.Button</a>
						</li>
						
						<li>
							<a href="cc.widget.Label.html">cc.widget.Label</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#__extends">__extends</a>
						</li>
						
						<li>
							<a href="global.html#test">test</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: node/Scene.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/**
 * License: see license.txt file.
 */
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// &lt;reference path="../action/Action.ts"/>
/// &lt;reference path="../action/SchedulerQueue.ts"/>
/// &lt;reference path="./Node.ts"/>
/// &lt;reference path="../action/ActionManager.ts"/>
/// &lt;reference path="../render/RenderingContext.ts"/>
/// &lt;reference path="../input/InputManager.ts"/>
var cc;
(function (cc) {
    var node;
    (function (_node) {
        "use strict";
        var Node = cc.node.Node;
        var ActionManager = cc.action.ActionManager;
        /**
         * @class cc.node.Scene
         * @extends cc.node.Node
         * @classdesc
         *
         * Scenes are specialized Nodes useful for separating in-game functional pieces.
         * For example, a Scene can be the game menu, another scene can be the game and another scene the results window.
         *
         * &lt;li>At any given moment, only one scene can be running.
         *
         * &lt;li>A Scene can not contain other Scenes, or any Director instance.
         * &lt;li>The size of the scene will by default be the same as the Director, and hence, equal to the Canvas size.
         *
         * &lt;li>A Scene manages all the Actions of all the Node's it contains.
         * &lt;li>A scene manages chronometers/events independently to any other scene.
         *
         * &lt;li>Every Node that hierarchically belongs to this Scene will have a reference to the Scene. This reference will be
         * set when the &lt;code>Director&lt;/code> the Scene is running in calls &lt;code>onEnter&lt;/code> on the scene.
         *
         * &lt;li>There´ no limitation on how many Scenes can be in a game.
         *
         * &lt;li>Scenes have no parent Node. This means that a call to &lt;code>enumerateChildren&lt;/code> will take a Scene as the
         * root search point.
         * &lt;li>An Scene logical parent is a Director object. Scenes have a Director instance in _parent variable.
         *
         * &lt;p>
         *     Scenes are the source point for input routing to the nodes it contains. It contains two members:
         *     &lt;ul>
         *      &lt;li>_sceneGraphPriorityTree: for nodes sorted in scene graph priority. This priority is the natural
         *       way nodes are organized.
         *      &lt;li>_priorityTree: artificial priority were nodes are sorted by value. lower value means higher priority.
         *     &lt;/ul>
         *     Each time a scene is set as running by a director, the InputSystem sets that scene as input target.
         *
         * &lt;p>
         *     One important thing about scenes is that they contain an ActionManager which at the same time, manages a
         *     Scheduler.
         *     Scheduling actions or tasks for a Node is as straighforward as calling &lt;code>runAction&lt;/code> or
         *     &lt;code>schedule|scheduleUpdate&lt;/code>.
         *     These methods expect a time parameter for scheduling, which by default is in seconds. The engine will internally
         *     treat all time measures in milliseconds (makes sense since the animation loop is scheduled every 16ms approx),
         *     but the developer can instrument to set time measurements in seconds (default) by calling
         *     &lt;code>cc.action.setTimeReferenceInSeconds&lt;/code> or milliseconds &lt;code>setTimeReferenceInMillis&lt;/code>.
         *     Callback notifications with a time parameter will be in the developer desired time units.
         *
         */
        var Scene = (function (_super) {
            __extends(Scene, _super);
            /**
             * Create a new Scene instance.
             * @method cc.node.Scene#constructor
             */
            function Scene() {
                _super.call(this);
                /**
                 * Node's ActionManager.
                 * @member cc.node.Scene#_actionManager
                 * @type {cc.action.ActionManager}
                 * @private
                 */
                this._actionManager = new ActionManager();
                /**
                 * Callback reference for onEnter event.
                 * @member cc.node.Scene#_onEnter
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onEnter = null;
                /**
                 * Callback reference for onExit event.
                 * @member cc.node.Scene#_onExit
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onExit = null;
                /**
                 * Callback reference for enter transition end event.
                 * @member cc.node.Scene#_onEnterTransitionDidFinish
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onEnterTransitionDidFinish = null;
                /**
                 * Callback reference for exit transition start event.
                 * @member cc.node.Scene#_onExitTransitionDidStart
                 * @type {cc.node.CallbackSceneTransition}
                 * @private
                 */
                this._onExitTransitionDidStart = null;
                this._scheduler = null;
                this._sceneGraphPriorityTree = null;
                this._priorityTree = null;
                this._scheduler = this._actionManager.getScheduler();
                this._sceneGraphPriorityTree = new cc.input.SceneGraphInputTreeNode(this);
                this._priorityTree = [];
                this.setGlobalAlpha(true);
                this.setPositionAnchor(0, 0);
            }
            Scene.prototype.enableEvents = function (enable) {
                _super.prototype.enableEvents.call(this, enable);
                this.enableEventsForNode(this);
                return this;
            };
            Scene.prototype.enablePriorityEvents = function (enable, priority) {
                _super.prototype.enablePriorityEvents.call(this, enable, priority);
                this.enableEventsForNode(this);
                return this;
            };
            /**
             * Enable events in scene-graph order for a node.
             * If the node is not attached to this scene, nothing will happen.
             * @method cc.node.Scene#enableEvents
             * @param node {cc.node.Node}
             */
            Scene.prototype.enableEventsForNode = function (node) {
                this._sceneGraphPriorityTree.insert(node.getPathToRoot());
                return this;
            };
            /**
             * Enable events in priority order for a node.
             * The priority is something external to the Node,
             * @method cc.node.Scene#enablePriorityEvents
             * @param node {cc.node.Node}
             */
            Scene.prototype.enablePriorityEventsForNode = function (node) {
                var pin;
                var pinIndex = -1;
                for (var i = 0; i &lt; this._priorityTree.length; i++) {
                    if (this._priorityTree[i].node === node) {
                        pinIndex = i;
                        break;
                    }
                }
                if (pinIndex !== -1) {
                    pin = this._priorityTree[pinIndex];
                    if (pin.priority === node.getInputPriority()) {
                        // node added with the same priority
                        return;
                    }
                }
                else {
                    // node does not exist. create descriptor, and insert.
                    this._priorityTree.push(new cc.input.PriorityInputNode(node, node.getInputPriority()));
                }
                this._priorityTree.sort(function (n0, n1) {
                    if (n0.priority &lt; n1.priority) {
                        return -1;
                    }
                    else if (n0.priority > n1.priority) {
                        return 1;
                    }
                    return 0;
                });
                return this;
            };
            Scene.prototype.findNodeAtScreenPoint = function (p, callback) {
                var pp = new cc.math.Vector();
                pp.set(p.x, p.y);
                for (var i = 0; i &lt; this._priorityTree.length; i++) {
                    var node = this._priorityTree[i].node;
                    p.set(pp.x, pp.y);
                    if (node.isScreenPointInNode(p)) {
                        if (callback) {
                            if (!callback(node)) {
                                return node;
                            }
                        }
                        else {
                            return node;
                        }
                    }
                }
                // now, for scene-graph priority.
                p.set(pp.x, pp.y);
                return this._sceneGraphPriorityTree.findNodeAtScreenPoint(p, callback);
            };
            /**
             * Increment scene's timeline.
             * This time is local to this scene, and independent to other Scene's time.
             * This local time is handled by the Scene's ActionManager, which translate the delta milliseconds into
             * the desired game time measurement unit, which are seconds by default.
             * @method cc.node.Scene#step
             * @param delta {number} elapsed time in milliseconds.
             * @param ctx {cc.render.RenderingContext} where node's will render.
             */
            Scene.prototype.step = function (delta, ctx) {
                // allow for this scene's nodes actions to run.
                this._actionManager.step(delta);
                // draw scene and its children.
                this.visit(ctx);
            };
            /**
             * Register Scene onEnter callback.
             * @method cc.node.Scene#onEnter
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onEnter = function (c) {
                this._onEnter = c;
                return this;
            };
            /**
             * Register Scene onExit callback.
             * @method cc.node.Scene#onExit
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onExit = function (c) {
                this._onExit = c;
                return this;
            };
            /**
             * Register onExitTransitionStart callback. Called when scenes are switched by Transition objects.
             * @method cc.node.Scene#onExitTransitionDidStart
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onExitTransitionDidStart = function (c) {
                this._onExitTransitionDidStart = c;
                return this;
            };
            /**
             * Register onEnterTransitionFinish callback. Called when scenes are switched by Transition objects.
             * @method cc.node.Scene#onEnterTransitionDidFinish
             * @param c {cc.node.CallbackSceneTransition}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.onEnterTransitionDidFinish = function (c) {
                this._onEnterTransitionDidFinish = c;
                return this;
            };
            /**
             * Notifiy event registered callback.
             * @method cc.node.Scene#callOnEnterTransitionDidFinish
             */
            Scene.prototype.callOnEnterTransitionDidFinish = function () {
                if (this._onEnterTransitionDidFinish) {
                    this._onEnterTransitionDidFinish(this);
                }
            };
            /**
             * Notifiy event registered callback.
             * @method cc.node.Scene#callOnExitTransitionDidStart
             */
            Scene.prototype.callOnExitTransitionDidStart = function () {
                if (this._onExitTransitionDidStart) {
                    this._onExitTransitionDidStart(this);
                }
            };
            /**
             * Notifiy event registered callback.
             *
             *
             * @method cc.node.Scene#callOnEnter
             */
            Scene.prototype.callOnEnter = function () {
                var scene = this;
                // recursively set scene for nodes.
                this.enumerateChildren("//*", function (node) {
                    node.setScene(scene);
                });
                if (this._onEnter) {
                    this._onEnter(this);
                }
                this.resetScene();
            };
            /**
             * Notify event registered callback.
             * @method cc.node.Scene#callOnExit
             */
            Scene.prototype.callOnExit = function () {
                if (this._onExit) {
                    this._onExit(this);
                }
            };
            /**
             * Overriden Node's method for set scene reference.
             * A scene does not need a scene reference.
             * @method cc.node.Scene#setScene
             * @param scene {cc.node.Scene}
             */
            Scene.prototype.setScene = function (scene) {
                // assert scene===this
            };
            /**
             * Overriden Node's method for setting a parent.
             * Scenes have no parent reference so this method does nothing.
             * @method cc.node.Scene#setParent
             * @param node {cc.node.Node}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.setParent = function (node) {
                return this;
            };
            /**
             * Reset this scene's properties.
             * Needed if the scene is managed by a Transition since position/scale/rotate can be changed.
             * @method cc.node.Scene#resetScene
             * @returns {cc.node.Scene}
             */
            Scene.prototype.resetScene = function () {
                this.alpha = 1;
                this.setScale(1, 1);
                this.setPositionAnchor(0, 0);
                this.setTransformationAnchor(0.5, 0.5);
                this.__setFlag(8 /* VISIBLE */);
                return this;
            };
            /**
             * Run an Action for a Node.
             * @method cc.node.Scene#scheduleActionForNode
             * @param node {cc.node.Node}
             * @param action {cc.action.Action}
             * @returns {cc.node.Scene}
             */
            Scene.prototype.scheduleActionForNode = function (node, action) {
                this._actionManager.scheduleActionForNode(node, action);
                return this;
            };
            /**
             * Clear all this scene contents.
             * + all children are removed.
             */
            Scene.prototype.clear = function () {
                this.removeAllChildren();
            };
            /**
             * Schedule an action to run.
             * By the time an action is meant to be scheduled for running in a Node, there may not yet be a
             * &lt;code>Director&lt;/code> or &lt;code>Scene&lt;/code>. This method saves locally the actions which will be
             * scheduled in a scene's &lt;code>ActionManager&lt;/code> later.
             * @method cc.node.Node#runAction
             * @param action {cc.action.Action}
             * @returns {cc.node.Node}
             */
            Scene.prototype.runAction = function (action) {
                this.scheduleActionForNode(this, action);
                return this;
            };
            Scene.prototype.stopNodeActionByTag = function (node, tag) {
                this._actionManager.stopNodeActionByTag(node, tag);
                return this;
            };
            Scene.prototype.stopActionsForNode = function (node) {
                this._actionManager.stopActionsForNode(node);
            };
            Scene.prototype.getScheduler = function () {
                return this._scheduler;
            };
            Scene.prototype.getScene = function () {
                return this;
            };
            /////////////// SCHEDULER METHODS BEGIN ////////////////
            Scene.prototype.scheduleTask = function (task) {
                this._scheduler.scheduleTask(task);
            };
            Scene.prototype.scheduleUpdateWithPriority = function (priority) {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, this.update, 0, Number.MAX_VALUE, 0);
                task._priority = priority;
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a task to per frame call update for this node.
             *
             * @method cc.node.Node#scheduleUpdate
             * @deprecated
             */
            Scene.prototype.scheduleUpdate = function () {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, this.update, 0, Number.MAX_VALUE, 0);
                this._scheduler.scheduleTask(task);
            };
            Scene.prototype.unscheduleUpate = function () {
                this._scheduler.unscheduleCallbackForTarget(this, this.update);
            };
            /**
             * Schedule a task for the node.
             * This node will be passed as target to the specified callback function.
             * If already exist a task in the scheduler for the same pair of node and callback, the task will be updated
             * with the new data.
             * @method cc.node.Node#schedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to invoke
             * @param interval {number} repeat interval time. the task will be fired every this amount of milliseconds.
             * @param repeat {number=} number of repetitions. if not set, infinite will be used.
             * @param delay {number=} wait this millis before firing the task.
             */
            Scene.prototype.schedule = function (callback_fn, interval, repeat, delay) {
                var task = cc.action.SchedulerQueue.createSchedulerTask(this, callback_fn, interval, repeat, delay);
                this._scheduler.scheduleTask(task);
            };
            /**
             * Schedule a single shot task. Will fired only once.
             * @method cc.node.Node#scheduleOnce
             * @param callback_fn {cc.action.SchedulerTaskCallback} scheduler callback.
             * @param delay {number} milliseconds to wait before firing the task.
             * @returns {cc.node.Node}
             */
            Scene.prototype.scheduleOnce = function (callback_fn, delay) {
                this.schedule(callback_fn, 0.0, 0, delay);
            };
            /**
             * Unschedule a task for the node.
             * @method cc.node.Node#unschedule
             * @param callback_fn {cc.action.SchedulerTaskCallback} callback to unschedule.
             */
            Scene.prototype.unschedule = function (callback_fn) {
                if (!callback_fn)
                    return;
                this._scheduler.unscheduleCallbackForTarget(this, callback_fn);
            };
            Scene.prototype.unscheduleCallbackForTarget = function (target, task) {
                this._scheduler.unscheduleCallbackForTarget(target, task);
            };
            /**
             * Unschedule all tasks for the node.
             * @method cc.node.Node#unscheduleAllCallbacks
             */
            Scene.prototype.unscheduleAllCallbacks = function (target) {
                this._scheduler.unscheduleAllCallbacks(target ? target : this);
            };
            /**
             * Resumes all scheduled tasks and actions.
             * This method is called internally by onEnter
             * @method cc.node.Node#resume
             */
            Scene.prototype.resume = function () {
                this._scheduler.resumeTarget(this);
                // PENDING: implement
                //this.actionManager &amp;&amp; this.actionManager.resumeTarget(this);
                //cc.eventManager.resumeTarget(this);
            };
            /**
             * Pauses all scheduled selectors and actions.
             * This method is called internally by onExit.
             * @method cc.node.Node#pause
             *
             */
            Scene.prototype.pause = function () {
                this._scheduler.pauseTarget(this);
                // PENDING: implement
                //this.actionManager &amp;&amp; this.actionManager.pauseTarget(this);
                //cc.eventManager.pauseTarget(this);
            };
            Scene.prototype.pauseTarget = function (target) {
                this._scheduler.pauseTarget(target);
            };
            Scene.prototype.resumeTarget = function (target) {
                this._scheduler.resumeTarget(target);
            };
            return Scene;
        })(Node);
        _node.Scene = Scene;
    })(node = cc.node || (cc.node = {}));
})(cc || (cc = {}));
</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					@hyperandroid
					<br />
					
					
		<span class="copyright">
		Chukong inc. 2014
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on 23/Tu/2015 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
